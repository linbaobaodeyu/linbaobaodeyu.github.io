<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林宝ᴗ宝の鱼</title>
  
  <subtitle>波妞喜欢宗介
我也喜欢妳
</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://linbaobaodeyu.github.io/"/>
  <updated>2019-03-25T08:53:15.975Z</updated>
  <id>https://linbaobaodeyu.github.io/</id>
  
  <author>
    <name>林宝ᴗ宝の鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python之面向对象编程</title>
    <link href="https://linbaobaodeyu.github.io/2018/07/31/Python%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>https://linbaobaodeyu.github.io/2018/07/31/Python之面向对象编程/</id>
    <published>2018-07-31T14:33:33.000Z</published>
    <updated>2019-03-25T08:53:15.975Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、类的对象、实例化、变量</strong></p><ol><li><p>概念：类就是class,将一类事物放到一起，类里面包含这类事物的各种函数方法，相当于一个模型，例如造汽车，造汽车就是一个类，类里面包含造轮胎，造车门等函数方法。类的实例化就是通过这个类，这个模型造出来的实际的东西，例如通过造汽车这个模型造出来了一个汽车，这个汽车就是这个类的一个实例。在类里面有类变量，写在类里面，函数外面，通常就是类变量，在函数里面类似于self.name 这种就是实例变量。类的对象在代码层指的就是self，在函数里都会默认有个参数为self，类里面的函数都是面向这个self对象，函数里面的self.name 这种变量也是的，所以在一个类的函数里面，各个函数可以直接调用类里的其他函数的self.name 这种变量，或是self.函数名这个函数。其实在实例化的时候就是将那个实例传递给这个类里面的self，所以这个实例会拥有这个类里面的所有属性，或是方法。</p></li><li><p>例子：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span>  <span class="comment">#类,类名都以大写字母开头，驼峰式取名</span></span><br><span class="line">   country = <span class="string">'China'</span> <span class="comment">#类变量</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">      self.name = <span class="string">'张三'</span> <span class="comment">#实例变量</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">cry</span><span class="params">(self)</span>:</span></span><br><span class="line">      print(<span class="string">'%s 哇哇哇'</span>%self.name) <span class="comment">#调用上一个函数里self.name</span></span><br><span class="line">      self.say()  <span class="comment">#调用函数say()</span></span><br><span class="line"></span><br><span class="line">a=Person() <span class="comment">#类的实例化</span></span><br><span class="line">a.cry() <span class="comment">#实例化后，相当于类里面的self变成了a</span></span><br><span class="line">Person.country  <span class="comment">#类变量可直接类.变量名 使用</span></span><br></pre></td></tr></table></figure><p><strong>二、实例方法、类方法、静态方法、属性方法</strong></p><ol><li>概念：</li></ol><p>实例方法：正常定义的函数都是实例方法，函数后默认参数self</p><p>类方法（方法名上一行加装饰器@classmethod）：</p><pre><code>a.可以不实例化，直接用类名调用，类名.函数名()，也可以实例化，实例化后也可以直接通过实例名.函数名()来使用类方法b.它可以使用类变量，cls.变量名c.在实例方法里，可以使用self.函数名()，来使用类方法d.在类方法里，它是不能用这些实例方法和实例变量，类似于self.xx这种</code></pre><p>静态方法（方法名上一行加装饰器@staticmethod）：</p><pre><code>a.就是一个普通的函数，只是定义在类里面而已b.用不了实例方法、用不了实例变量、也用不了类方法、类变量c.也不需要实例化，直接类名.方法名()调用即可</code></pre><p>属性方法(方法名上一行加装饰器@property)：</p><pre><code>a.看起来像变量的一个函数b.是个实例方法c. 它不能有入参d.用它的时候，直接实例名.函数名，把它当做一个变量用就ok了，不需要加括号调用e.它是获取函数的返回值，return的值</code></pre><ol start="2"><li>例子：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My</span>:</span></span><br><span class="line">   country =<span class="string">'China'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span>   <span class="comment">#实例方法</span></span><br><span class="line">   print(<span class="string">'实例方法'</span>)</span><br><span class="line">   self.eat()  <span class="comment">#调用类方法</span></span><br><span class="line"><span class="meta">@classmethod   #类方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(cls)</span>:</span>  <span class="comment">#class，不是self</span></span><br><span class="line">   print(cls.country)  <span class="comment">#使用类变量</span></span><br><span class="line">   print(<span class="string">'类方法'</span>)</span><br><span class="line">   cls.run() <span class="comment">#调用静态方法</span></span><br><span class="line"><span class="meta">@staticmethod  #静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'静态方法'</span>)</span><br><span class="line"><span class="meta">@property  #属性方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">red_pag</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p><strong>三、构造函数、析构函数</strong></p><ol><li>概念：</li></ol><p>构造函数：构造函数，类在实例化的时候，会自动执行它</p><p>析构函数：析构函数，这个实例被销毁的时候自动执行的</p><ol start="2"><li>例子：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>   <span class="comment">#构造函数</span></span><br><span class="line">   print(<span class="string">'构造函数，类在实例化的时候，会自动执行它'</span>)</span><br><span class="line">　 self.__client = pymongo.MongoClient(host=<span class="string">'xxxxxx'</span>,port=xxx) <span class="comment">#类似于连接数据库的可以放在构造函数里，在实例化时就连一次连上</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span>   <span class="comment">#析构函数</span></span><br><span class="line">　　print(<span class="string">'析构函数，这个实例被销毁的时候自动执行的'</span>)</span><br><span class="line">　　self.__client.close()  <span class="comment">#类似于关闭数据库连接的可以放在析构函数里</span></span><br></pre></td></tr></table></figure><p><strong>四、继承、私有</strong></p><ol><li>私有：函数名或者变量名前面加__，这个函数或者变量就是私有的，私有只能在类里面用。</li></ol><p>例子：<br>def <strong>cry(self): #私有函数，只能类里面用，在类里面的其他函数里可通过self.</strong>xx调用到该函数，但是在类外或是实例的时候无法调用到该函数<br>　　print(‘私有’)</p><ol start="2"><li>继承：继承就是一个类继承了另一个类后，会拥有另一个类的属性，例如变量或函数，但是如果在本类里有相同名称的方法或变量，优先于是本类，不会再去父类找。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">例子<span class="number">1</span>：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>:</span>           <span class="comment">#父类</span></span><br><span class="line">   money = <span class="string">'2000'</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">make_money</span><span class="params">(self)</span>:</span></span><br><span class="line">      print(<span class="string">'挣钱'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span><span class="params">(Father)</span>:</span>     <span class="comment">#子类</span></span><br><span class="line">　　<span class="keyword">pass</span></span><br><span class="line">a=Son()</span><br><span class="line">a.make_money() <span class="comment">#调用到父类的函数</span></span><br><span class="line">print(a.money) <span class="comment">#调用到父类的变量</span></span><br><span class="line"></span><br><span class="line">例子<span class="number">2</span>：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span>:</span>  <span class="comment">#父类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">      print(<span class="string">'one'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span><span class="params">(One)</span>:</span> <span class="comment">#子类，继承父类One</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self,name)</span>:</span></span><br><span class="line">      super().say()   <span class="comment">#执行父类方法，如果想不更改继承的父类方法下，又在父类方法上新增功能，则super().函数名()就是执行相应的父类方法</span></span><br><span class="line">      print(<span class="string">'%sTwo'</span> %name)</span><br><span class="line"></span><br><span class="line">b=Two()</span><br><span class="line">b.say(<span class="string">'yuze'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、类的对象、实例化、变量&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;概念：类就是class,将一类事物放到一起，类里面包含这类事物的各种函数方法，相当于一个模型，例如造汽车，造汽车就是一个类，类里面包含造轮胎，造车门等函数方法。类的实例化就是通过这
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="面向对象" scheme="https://linbaobaodeyu.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="测试" scheme="https://linbaobaodeyu.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Python之网络编程（requests模块）</title>
    <link href="https://linbaobaodeyu.github.io/2018/07/29/Python%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88requests%E6%A8%A1%E5%9D%97%EF%BC%89/"/>
    <id>https://linbaobaodeyu.github.io/2018/07/29/Python之网络编程（requests模块）/</id>
    <published>2018-07-29T14:10:37.000Z</published>
    <updated>2019-03-25T08:53:15.974Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、requests模块的基本方法</strong></p><pre><code>import requests</code></pre><ol><li><p>res = requests.get(url,params={‘stu_name’:’小黑’})   #发送get请求,传参k-v形式</p></li><li><p>data={‘user’:’useraccount’,’pwf’:’password’}</p><pre><code>res = requests.post(url,data=data)      #发送post请求，传参k-v形式</code></pre></li><li><p>data={“name”:”requests_name”,”grade”:”天蝎座”}</p><pre><code>res = requests.post(url,json=data)     #发送post请求，入参是json类型的</code></pre></li><li><p>cookie = {‘zhangsan’:’abd9a0995f4696e1a60133220b32037a’}</p><pre><code>res = requests.post(url,data=data,cookies=cookie)  #发送post请求，带cookie的</code></pre></li><li><p>header = {‘Referer’:’<a href="http://api.nnzhp.cn/&#39;}" target="_blank" rel="noopener">http://api.nnzhp.cn/&#39;}</a></p><p> res=requests.get(url,headers=header)  #发送get请求，带header的</p></li><li><p>res = requests.get(url,verify=False)   #发送https请求，需加上verify=False</p></li><li><p>res.json()     #把返回的结果转成字典，必须返回是json</p></li><li><p>res.text       #返回成字符串</p></li><li><p>res.content  #用来下载文件用的，返回的是二进制</p></li><li><p>res.headers  #获取到返回的所有header</p></li><li><p>res.cookies   #获取到返回的所有cookie</p></li><li><p>res.status_code   #获取到请求响应的状态码</p></li></ol><p><strong>二、例子</strong></p><p>例子一（下载图片）：</p><pre><code>url6=&apos;https://aliimg.changba.com/cache/photo/855e5493-f018-44db-8892-c8660649327b_640_640.jpg&apos;res = requests.get(url6,verify=False) #verify=False如果是https的话加上这个with open(&apos;tu.jpg&apos;,&apos;wb&apos;) as fw: #打开一个文件     fw.write(res.content) #将请求获取到的结果写入到文件里去，是文件，所以是res.content二进制</code></pre><p>例子二（获取qq群的成员信息存入到mongodb里以及下载成员的头像保存到本地）：</p><pre><code>import pymongo,osclient = pymongo.MongoClient(host=&apos;x.x.x.x&apos;,port=xxxx)db=client[&apos;qq_group&apos;]table = db[&apos;xxx&apos;]url = &quot;https://qun.qq.com/cgi-bin/qun_mgr/search_group_members&quot;data = {&quot;gc&quot;:xxxxx,&quot;st&quot;:0,&quot;end&quot;:200,&quot;sort&quot;:0,&quot;bkn&quot;:xxxxxxx}header = {&quot;Cookie&quot;:&quot;pgv_pvi=1977809920; tvfe_boss_uuid=d8ce464d0b7bd6f6; RK=6RFHD8oPOz; ptcz=11c139fb4d425800954a94bcb78d8b04222ef05985e6b9ac493a28744decc178; pgv_pvid=744932512; ptui_loginuin=2851662269; o_cookie=2851662269; pt2gguin=o0469873580; uin=o0469873580; ptisp=ctc; pgv_si=s8086261760; skey=@LfPHQ7sb0; p_uin=o0469873580; pt4_token=sf7OadX0vT5Mv4PiIQ3xkHbiI9quA5GB75z8lMcLgag_; p_skey=PcX00u1AVFRWKu6N1S62ooT13P*JDcCOhq64nknIlGQ_&quot;}res = requests.post(url=url,data=data,headers=header)mems = res.json().get(&quot;mems&quot;)#获取到该群的所有成员的信息for i in mems:    mem = {        &quot;qq&quot;:i.get(&quot;uin&quot;),        &quot;gender&quot;:i.get(&quot;g&quot;),        &quot;nick&quot;:i.get(&quot;nick&quot;),        &quot;card&quot;:i.get(&quot;card&quot;),        &quot;qage&quot;:i.get(&quot;qage&quot;)    }    if mem.get(&quot;gender&quot;) == 0:       mem[&apos;gender&apos;] = &quot;男&quot;    elif mem.get(&quot;gender&quot;) == 1:        mem[&apos;gender&apos;] = &quot;女&quot;    else:       mem[&apos;gender&apos;] = &quot;未知&quot;    if mem.get(&quot;card&quot;) == &quot;&quot;:        mem[&apos;card&apos;] = &quot;没有群名片&quot;    table.insert_one(mem)    qq = mem.get(&quot;qq&quot;)    url= &quot;http://q4.qlogo.cn/g?b=qq&amp;nk={}&amp;s=140&quot;.format(qq)     pics = requests.get(url)    abs_path=os.path.join(&apos;pics&apos;,str(qq)+&apos;.jpg&apos;) #拼接路径，都把图片保存到一个文件夹下面    with open(abs_path,&quot;wb&quot;) as f:　　　　　　f.write(pics.content)　　print(&apos;%s的头像已经下载完成.&apos;%mem.get(&quot;nick&quot;))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、requests模块的基本方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import requests
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;res = requests.get(url,params={‘stu_name’:’小黑’
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="测试" scheme="https://linbaobaodeyu.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="requests" scheme="https://linbaobaodeyu.github.io/tags/requests/"/>
    
  </entry>
  
  <entry>
    <title>Python之异常处理</title>
    <link href="https://linbaobaodeyu.github.io/2018/07/29/Python%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://linbaobaodeyu.github.io/2018/07/29/Python之异常处理/</id>
    <published>2018-07-29T13:38:03.000Z</published>
    <updated>2019-03-25T08:53:15.973Z</updated>
    
    <content type="html"><![CDATA[<p>一、异常处理</p><p>通常在写程序的时候会预知一些程序可能发生的异常做判断，但是又不可能全面，例如sql语句错误，有很多种又不可能都写出来，而程序在发生异常报错的时候，代码会终止，不会往下执行，这种时候我们就需要进行异常处理，让程序遇到异常能抛出，并且能正常执行后面的代码。</p><p>二、例子</p><p>money = 1000<br>num = input(‘plese enter a num:’)<br>try:<br>   num = float(num)<br>   res = money/num<br>except Exception as e: #出现异常了，就走except下面的代码<br>   print(‘出现异常了’)<br>   print(‘你输入的价格不合法。。’)<br>   print(e)  #打印出异常信息<br>else:   #没有出现异常，执行下面代码<br>   money-=num<br>   print(num)<br>   print(‘你的余额是%s’%money)<br>finally:  #程序最后一定会执行的，无论是否出现异常<br>   print(‘我是finally’)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、异常处理&lt;/p&gt;
&lt;p&gt;通常在写程序的时候会预知一些程序可能发生的异常做判断，但是又不可能全面，例如sql语句错误，有很多种又不可能都写出来，而程序在发生异常报错的时候，代码会终止，不会往下执行，这种时候我们就需要进行异常处理，让程序遇到异常能抛出，并且能正常执行后面的
      
    
    </summary>
    
    
      <category term="异常" scheme="https://linbaobaodeyu.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>python之操作mysql、redis、mongodb</title>
    <link href="https://linbaobaodeyu.github.io/2018/07/19/python%E4%B9%8B%E6%93%8D%E4%BD%9Cmysql%E3%80%81redis%E3%80%81mongodb/"/>
    <id>https://linbaobaodeyu.github.io/2018/07/19/python之操作mysql、redis、mongodb/</id>
    <published>2018-07-19T13:06:34.000Z</published>
    <updated>2019-03-25T08:53:15.976Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、操作mysql</strong></p><pre><code>import pymysqldef my_db(ip,user,passwd,db,sql,port=3306,charset=&apos;utf8&apos;):   coon = pymysql.connect(host=ip,user=user,               password=passwd,db=db,               port=port,charset=charset,autocommit=True)   cur = coon.cursor()   #建立游标   sql=sql.strip()   cur.execute(sql)   #执行sql语句，但不会返回执行的结果   sql_start = sql[:6].lower()#取sql的开头,转成小写   if sql_start.startswith(&apos;select&apos;) or sql_start.startswith(&apos;show&apos;):      data = cur.fetchall()  #获取到查询的所有结果   else:      data = &apos;ok&apos;   cur.close()  #关闭游标   coon.close()  #关闭连接   return data</code></pre><p><strong>二、操作redis</strong></p><pre><code>import redisr = redis.Redis(host=&apos;x.x.x.x&apos;,port=6379,password=&apos;xxx&apos;,db=10)#1.操作string类型r.set(&apos;a&apos;,&apos;age18&apos;) #增加、修改数据res = r.get(&apos;111&apos;)  #获取数据r.delete(&apos;nhy_info&apos;) #指定一个key删除res.decode() #编码，就变成了字符串r.keys(&apos;*info&apos;) #获取到所有的keyr.exists(&apos;dashu_name&apos;)) #判断这个key是否存在r.flushdb()#可以清空当前数据库里面所有的keyr.expire(&apos;session_crm&apos;,600)#指定key的失效时间，秒为单位r.ttl(&apos;session_crm&apos;))#用来看这个key的失效时间def op_redis_str(k,t=None,v=None):    r = redis.Redis(**REDIS_INFO)    if v and t==None:        r.set(k,v)    elif v and t:        r.set(k,v)        r.expire(k,t)    elif v==None:        res=r.get(k)        if res==None:            return None        else:            return res.decode()</code></pre><p>###2.操作hash类型<br>    r.hset(‘session_crm’,’liuxinyu’,’sdfjksdklfjssdf’) #增加、修改（大k,小k，值）<br>    r.hdel(‘session_crm’,’liuxinyu’) #删除指定的小key<br>    r.delete(‘session_crm’) #直接删除大key<br>    r.hget(‘session_crm’,’zhouyifan_’) #获取指定小key里面的数据<br>    res = r.hgetall(‘session_crm’)#获取到hash类型里面所有的数据<br>    def op_hash(k1, k2=None, v=None):<br>         if v and k2:<br>             r.hset(k1,k2,v)<br>         elif v==None and k2==None:<br>             res2=r.hgetall(k1)<br>             for k, v in res2.items():<br>                res2[k.decode()]=res2.pop(k).decode()<br>             return res2<br>         elif v==None and k2:<br>             res3=r.hget(k1,k2)<br>             return res3.decode()<br><strong>三、操作mongodb</strong></p><pre><code>import pymongoclient = pymongo.MongoClient(host=&apos;x.x.x.x&apos;,port=27017)db = client[&apos;szp&apos;]  #选择数据库，如果这个数据库不存的话，会帮你创建collection = db[&apos;stu_info&apos;] #选择一个集合，就相当于mysql里面表db[&apos;stu_info&apos;].insert({&apos;url&apos;:&apos;http://www.baidu.com&apos;,&apos;title&apos;:&apos;baidu.com&apos;,&apos;addr&apos;:&apos;西二旗&apos;})for d in db[&apos;stu_info&apos;].find({&apos;title&apos;:&apos;baidu.com&apos;}):     print(d)collection.delete_one({&apos;title&apos;:&apos;baidu.com&apos;})  #如果有多条的话，只会帮你删掉1条collection.delete_many({&apos;title&apos;:&apos;baidu.com&apos;})#会删除多条print(list(collection.find()))collection.update({&apos;jd&apos;:&apos;www.jd.com&apos;},{&apos;jd&apos;:&apos;www.jd.com&apos;,&apos;addr&apos;:&apos;亦庄&apos;})</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、操作mysql&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import pymysql
def my_db(ip,user,passwd,db,sql,port=3306,charset=&amp;apos;utf8&amp;apos;):
   coon = p
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="测试" scheme="https://linbaobaodeyu.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="mysql" scheme="https://linbaobaodeyu.github.io/tags/mysql/"/>
    
      <category term="redis" scheme="https://linbaobaodeyu.github.io/tags/redis/"/>
    
      <category term="mongodb" scheme="https://linbaobaodeyu.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>Python之操作excel</title>
    <link href="https://linbaobaodeyu.github.io/2018/07/16/Python%E4%B9%8B%E6%93%8D%E4%BD%9Cexcel/"/>
    <id>https://linbaobaodeyu.github.io/2018/07/16/Python之操作excel/</id>
    <published>2018-07-16T13:45:26.000Z</published>
    <updated>2019-03-25T08:53:15.974Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、写excel</strong></p><pre><code>import  xlwtbook=xlwt.Workbook()      #创建excelsheet=book.add_sheet(&apos;sheet1&apos;)   #加一个sheetsheet.write(0,0,&apos;学生编号&apos;)   #行，列，数据for index,line_data in enumerate(data):     #使用枚举，循环写数据到excel　　for index2,col_data in enumerate(line_data):　　　　sheet.write(index,index2,col_data)book.save(&apos;1.xls&apos;)  #保存的后缀得是xls</code></pre><p><strong>二、读excel</strong></p><pre><code>import  xlrdbook = xlrd.open_workbook(&apos;nhy.xls&apos;)book.nsheets    #获取到excel里面总共有多少个sheet页sheet = book.sheet_by_index(0)  #按index来找sheetbook.sheet_by_name(&apos;sheet1&apos;)   #按name来找sheetsheet.cell(0,0).value  #指定行和列，获取某个单元格里面的内容sheet.row_values(0)   #获取某一行的数据sheet.nrows     #这个就是excel里面总共有多少行sheet.col_values(0)     #获取某一列的数据sheet.ncols                #总共有多少列</code></pre><p><strong>三、修改excel</strong></p><pre><code>import xlrdfrom xlutils import copybook1 = xlrd.open_workbook(&apos;nhy.xls&apos;)    #打开原来的excelnew_book = copy.copy(book1)   #拷贝一个新的excelsheet = new_book.get_sheet(0)  #获取第一个sheet页sheet.write(1,3,&apos;王艳会&apos;)   #改数据new_book.save(&apos;nhy.xls&apos;)  #命名为原来的excel</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、写excel&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import  xlwt

book=xlwt.Workbook()      #创建excel

sheet=book.add_sheet(&amp;apos;sheet1&amp;apos;)   #加一
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Python的模块安装、导入</title>
    <link href="https://linbaobaodeyu.github.io/2018/07/16/Python%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E3%80%81%E5%AF%BC%E5%85%A5/"/>
    <id>https://linbaobaodeyu.github.io/2018/07/16/Python的模块安装、导入/</id>
    <published>2018-07-16T13:17:02.000Z</published>
    <updated>2019-03-25T08:53:15.976Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、模块的安装</strong></p><ol><li>有网络的情况下：</li></ol><p>直接在cmd里面，输入<code>pip install  xxx</code> ，就是安装某个模块</p><ol start="2"><li><p>无网络的情况下，下下来的安装包：</p><pre><code>.whl的后缀，pip install xxx.whl.tar.gz的后缀，解压后，进入模块文件夹，执行： python setup.py install</code></pre></li></ol><p>3.卸载：<code>pip uninstall xxx</code></p><p><strong>二、导入模块的顺序</strong></p><ol><li><p>第一步去当前目录下找这个python文件</p></li><li><p>第二步去python的环境变量里面找这个python文件</p></li><li><p>导入模块的实质就是把这个模块的代码，从头到尾的执行一次</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、模块的安装&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有网络的情况下：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直接在cmd里面，输入&lt;code&gt;pip install  xxx&lt;/code&gt; ，就是安装某个模块&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
      <category term="python" scheme="https://linbaobaodeyu.github.io/categories/python/"/>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Python的模块（二）</title>
    <link href="https://linbaobaodeyu.github.io/2018/07/16/Python%E7%9A%84%E6%A8%A1%E5%9D%97%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://linbaobaodeyu.github.io/2018/07/16/Python的模块（二）/</id>
    <published>2018-07-16T12:58:06.000Z</published>
    <updated>2019-03-25T08:53:15.976Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、OS模块的补充</strong></p><ol><li><p>os.path.abspath(‘..\day3’)     #取绝对路径（相对路径换绝对路径），路径会按照当前系统的方式， 一个点是当前目录， 两个点是上一级目录</p></li><li><p>os.listdir(e:\spz\day3)   #获取目录下的文件</p></li><li><p>os.chdir(‘e:\spz\day3’)  #更改当前工作目录</p></li><li><p>os.system(‘ipconfig’)   #用来执行操作系统命令,但是只能帮你执行，获取不到结果</p></li><li><p>os.popen(‘ipconfig’).read()  #用来执行操作系统命令，获取到执行后结果</p></li></ol><p><strong>二、datetime模块</strong></p><ol><li><p>datetime.date.today()   #当天的日期，只有日期</p></li><li><p>datetime.datetime.today()  #当天的时间，有日期有时间</p></li><li><p>datetime.date.today()+datetime.timedelta(days=-2)    #取几天前或几天后的日期，-2就是取两天前的</p></li><li><p>res = datetime.datetime.today() + datetime.timedelta(hours=-10,minutes=-20)</p></li></ol><blockquote><p>res.time()  #只取到时间</p></blockquote><blockquote><p>res.date()  #只取到日期</p></blockquote><blockquote><p>res.timestamp())  #时间戳</p></blockquote><blockquote><p>res.strftime(‘%Y-%m %H:%M:%S’)  #取到格式化好的时间</p></blockquote><p><strong>三、random模块</strong></p><ol><li><p>random.random()  #取小于1的随机的小数</p></li><li><p>random.randint(1,10))  #取随机整数，可指定范围，包含头尾的</p></li><li><p>random.choice(x))  #随机在x中选择一个，只选择一个</p></li><li><p>random.sample(x,9)) #随机在x中选择9个值，返回的是一个list</p></li><li><p>random.uniform(8.5,8.8))  #指定一个范围，然后取一个随机小数</p></li></ol><p><strong>四、nnlog模块（写日志）</strong></p><ol><li><p>my_log=nnlog.Logger(‘yuze.log’,when=’S’,backCount=5)  #只保留5个日志文件，日志文件按日期到秒来</p></li><li><p>my_log.debug(‘这是debug的’)</p></li><li><p>my_log.info(“info级别的”)</p></li><li><p>my_log.warning(“waring 级别的”)  </p></li><li><p>my_log.error(“出错了 级别的”)</p></li></ol><p><strong>五、yagmail发邮件模块</strong></p><pre><code>useraccount=&apos;xxxxx@qq.com&apos;password=&apos;xxxx&apos;     #邮箱的授权码mail=yagmail.SMTP(user=useraccount,password=password,host=&apos;smtp.qq.com&apos;,smtp_ssl=True)   #smtp_ssl=True,如果是qq邮箱加上这个安全协议的mail.send(to=[&apos;xxxxx@qq.com&apos;,&apos;xxxxx@qq.com&apos;],cc=&apos;xxxx@qq.com&apos;,subject=&apos;吃了吗？&apos;,contents=&apos;哈哈&apos;,attachments=r&apos;C:\Users\xxx\1.py&apos;)</code></pre><p><strong>六、hashlib加密模块</strong></p><pre><code>def myMd5(s):　　s = str(s)　　m = hashlib.md5(s.encode())  #md5加密必须得传一个bytes类型的，用encode()　　return m.hexdigest()   #获取到加密后的结果</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、OS模块的补充&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;os.path.abspath(‘..\day3’)     #取绝对路径（相对路径换绝对路径），路径会按照当前系统的方式， 一个点是当前目录， 两个点是上一级目录&lt;/p&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="python" scheme="https://linbaobaodeyu.github.io/categories/python/"/>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Python的模块（一）</title>
    <link href="https://linbaobaodeyu.github.io/2018/07/03/Python%E7%9A%84%E6%A8%A1%E5%9D%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://linbaobaodeyu.github.io/2018/07/03/Python的模块（一）/</id>
    <published>2018-07-03T14:20:20.000Z</published>
    <updated>2019-03-25T08:53:15.976Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、常用模块–OS（提供了非常丰富的方法用来处理文件和目录）</strong></p><ol><li>import os</li></ol><blockquote><p>os.getcwd()  #获取当前路径</p></blockquote><blockquote><p>os.mkdir(‘e:\nhy123’)  #创建文件夹</p></blockquote><blockquote><p>os.makedirs(‘stu\laowang’)  #父目录不存在的时候会帮你创建父目录</p></blockquote><blockquote><p>os.listdir(r’C:\Miniconda3\Scripts’)  #获取某个目录下的所有文件</p></blockquote><blockquote><p>os.rmdir(‘stu’)  #删除空文件夹</p></blockquote><blockquote><p>os.path.join(‘nhy123’,’test0’,’a.txt’)  #拼接路径，它会自动识别路径分隔符</p></blockquote><blockquote><p>os.sep  #当前系统的路径分隔符</p></blockquote><blockquote><p>os.path.dirname(‘e:\nhy123\test0\a.txt’)  #获取父目录的路径</p></blockquote><blockquote><p>os.path.getsize(‘e:\nhy123\test0\a.txt’)   #获取文件大小的</p></blockquote><blockquote><p>os.path.exists(‘code’)  #判断文件、文件夹是否存在</p></blockquote><blockquote><p>os.path.isdir(‘e:\11’)  #判断是否是文件夹,如果文件夹不存在的话，会返回False</p></blockquote><blockquote><p>os.path.isfile(r’e:\nhy123\test0\a.txt’)  #判断是否是文件，如果文件不存在的话，会返回False</p></blockquote><blockquote><p>os.path.split(r’e:\nhy123\test0\a.txt’)   #分割文件名和路径的</p></blockquote><p><strong>二、常用模块-time(日期相关)</strong></p><ol><li>import time</li></ol><blockquote><p>int(time.time())   #获取当前时间戳</p></blockquote><blockquote><p>time.strftime(‘%Y-%m-%d %H:%M:%S’)    #格式化好的时间</p></blockquote><blockquote><p>time.gmtime()   #把时间戳转成时间元组，如果不传时间戳，那么取的是标准时区的时间元组</p></blockquote><blockquote><p>time.localtime()  #把时间戳转成时间元组，如果不传时间戳，那么取的是当前时区的时间</p></blockquote><ol start="2"><li>时间戳与格式好的时间互相转换</li></ol><p>a、时间戳转格式化好的时间</p><pre><code>   # 1、首先要把时间戳转成时间元组   # 2、再把时间元组转成格式化好的时间def timestampToStr(timestamp=None,format=&apos;%Y-%m-%d %H:%M:%S&apos;):   if timestamp:      time_tuple = time.localtime(timestamp)  # 转成时间元组      return time.strftime(format,time_tuple) #把时间元组，转成格式化好的时间   return time.strftime(format)</code></pre><p>b、格式化好的时间，转时间戳</p><pre><code>   #1、首先要把格式化好的时间 转成时间元组   #2、再把时间元组转成时间戳def strToTimestamp(format_time=None,format=&apos;%Y%m%d%H%M%S&apos;):   if format_time:      time_tuple = time.strptime(format_time, format)#把格式化好的时间，转成时间元组      return int(time.mktime(time_tuple))   return int(time.time())</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、常用模块–OS（提供了非常丰富的方法用来处理文件和目录）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;import os&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;os.getcwd()  #获取当前路径&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="python" scheme="https://linbaobaodeyu.github.io/categories/python/"/>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Python的函数（二）</title>
    <link href="https://linbaobaodeyu.github.io/2018/07/03/Python%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://linbaobaodeyu.github.io/2018/07/03/Python的函数（二）/</id>
    <published>2018-07-03T13:38:50.000Z</published>
    <updated>2019-03-25T08:53:15.975Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、函数相关概念</strong></p><ol><li><p>全局变量：在函数外，上方定义的变量就是全局变量</p></li><li><p>局部变量：在函数里定义的，出了函数后就不能使用了，如果想在函数里修改全局变量的值，则需要在函数里变量前加关键字global，但是字典跟list这个可变变量，不需要用</p></li></ol><p>global来声明，直接就可以改了。</p><ol start="3"><li>参数的几个例子：</li></ol><p>a.可变参数,参数组-元组形式：</p><pre><code>def send_mail(*args):   print(args)send_mail(&apos;1111@qq.com&apos;,&apos;2222@qq.com&apos;,&apos;3333@qq.com&apos;)</code></pre><p>b.可变参数,参数组-字典形式：</p><pre><code>def send_mail(**kwargs):   print(kwargs)send_mail(k1=&apos;v1&apos;,k2=&apos;v2&apos;)</code></pre><p><strong>二、函数的递归</strong></p><ol><li><p>函数自己调用自己，最多循环999次</p></li><li><p>用递归的话，必须得有一个明确的结束条件</p></li><li><p>例子：</p><pre><code>def my2():   num = input(&apos;输入一个数字：&apos;)   num = int(num)   if num%2 !=0:      print(&apos;请输入偶数&apos;)      return my2()my2()</code></pre></li></ol><p><strong>三、列表推导式、列表生成式</strong></p><ol><li><p>例子：</p><pre><code>import randomres = [26, 7, 18, 27, 32, 28] for i in range(len(res)):   res[i] = str(res[i]).zfill(2)#列表推导式，列表生成式res1 = [ str(i).zfill(2) for i in res]--等同于上面的for循环print(res1)res2 = [ i+10 for i in res ] print(res2)hh = [ i for i in range(0,1001,2)] print(hh)</code></pre></li></ol><p><strong>四、内置函数</strong></p><ol><li><p>max(range(1,28)) –最大值，运行结果：27</p></li><li><p>min(range(28)) –最小值，运行结果：0</p></li><li><p>sum(range(1,101)) –求和，运行结果：5050</p></li><li><p>res = sorted([2,3,1,2,3],reverse=True)  –排序，加上reverse=True就是降序排列了</p></li><li><p>res = eval(‘1+1’)  –eval,执行python代码，只能执行简单的python代码</p></li><li><p>f = open(‘code’,encoding=’utf-8’)   code = f.read()   exec(code)  —exec,可执行在文件里的python代码</p></li><li><p>sql = ‘insert into my_user value ({id},{name},{addr},{sex},{phone}) ‘</p><p>sql.format(name=’aaa’,addr=’sdfsfd’,sex=’xxx’,id=11)  –format函数是格式化字符串的函数</p></li><li><p>for index,s in enumerate(stus): print(index,s)   –enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中，返回 enumerate(枚举) 对象，如果下标起始位置写为1，就返回的是从序号1开始枚举对象。</p></li><li><p>for name,se,ag in zip(stus,sex,age):print(name,se,ag)   –多个list压缩到一起</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、函数相关概念&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;全局变量：在函数外，上方定义的变量就是全局变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局部变量：在函数里定义的，出了函数后就不能使用了，如果想在函数里修改全局变量的值，则需要在函数里变量前加关键
      
    
    </summary>
    
      <category term="python" scheme="https://linbaobaodeyu.github.io/categories/python/"/>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Python的函数（一）</title>
    <link href="https://linbaobaodeyu.github.io/2018/06/19/Python%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://linbaobaodeyu.github.io/2018/06/19/Python的函数（一）/</id>
    <published>2018-06-19T14:04:35.000Z</published>
    <updated>2019-03-25T08:53:15.975Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、函数的介绍</strong></p><ol><li><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段</p></li><li><p>如果需要用到函数的处理结果的话，那么就写return，函数里面如果碰到return，函数立即结束</p></li><li><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p></li><li><p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。</p></li><li><p>当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字。</p></li><li><p>参数</p></li></ol><p>必需参数：def a(b)     调用时必需传入一个参数，a(b)</p><p>关键字参数：def  s(a,b)   调用时函数调用使用关键字参数来确定传入的参数值，不需要用指定顺序，s(b=1,a=2)</p><p>默认参数：def   s(a,b=1)    调用函数时，如果没有传递参数，则会使用默认参数值。s(a=1)  </p><p>不定长参数： 你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数。</p><blockquote><p>def s(a,<em>vartuple)   –加了星号 </em> 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数</p></blockquote><blockquote><p>def  s(a,<strong>vardict)  –加了两个星号 </strong> 的参数会以字典的形式导入</p></blockquote><p><strong>二、函数的使用(例子，校验输入的字符串是否为小数的程序)</strong></p><pre><code>def check_float(s):   s = str(s)   if s.count(&apos;.&apos;)==1:      s_list = s.split(&apos;.&apos;)      left = s_list[0] #小数点左边       right = s_list[1]#小数点右边      if left.isdigit() and right.isdigit(): #这里是判断正小数的         return True      if left.startswith(&apos;-&apos;)  and left[1:].isdigit() and right.isdigit():  #判断负小数的         return True   return False</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、函数的介绍&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果需要用到函数的处理结果的话，那么就写return，函数里面如果碰到return，函数立即
      
    
    </summary>
    
      <category term="python" scheme="https://linbaobaodeyu.github.io/categories/python/"/>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Python的集合</title>
    <link href="https://linbaobaodeyu.github.io/2018/06/19/Python%E7%9A%84%E9%9B%86%E5%90%88/"/>
    <id>https://linbaobaodeyu.github.io/2018/06/19/Python的集合/</id>
    <published>2018-06-19T13:37:27.000Z</published>
    <updated>2019-03-25T08:53:15.976Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、集合的介绍</strong></p><ol><li><p>集合天生去重</p></li><li><p>集合也是无序的</p></li><li><p>集合的作用主要是关系测试，测试两组数据之前的交集，差集，并集,子集，父集，对称（反向）差集等关系</p></li></ol><p><strong>二、集合的使用方法</strong></p><blockquote><p>a = {6,7,1,2,3,4,5}    #创建一个集合</p></blockquote><blockquote><p>b=set([1,2,3,4,8])       #创建一个集合</p></blockquote><blockquote><p>a &amp; b    #交集，同时存在于a跟b中的，运行结果：{1, 2, 3, 4}</p></blockquote><blockquote><p>a | b      # 并集，a与b合并后的结果，运行结果：{1, 2, 3, 4, 5, 6, 7, 8}</p></blockquote><blockquote><p>a -b       #差集，a在b中没有的，运行结果：{5, 6, 7}</p></blockquote><blockquote><p>a ^ b    # 对称差集，a和b互相没有的，运行结果：{5, 6, 7, 8}</p></blockquote><blockquote><p>a.add(‘x’)   #集合中添加一项</p></blockquote><blockquote><p>a.update([888,999])   #集合中添加多项</p></blockquote><blockquote><p>a.remove(999)   #删除一项，不存在会报错</p></blockquote><blockquote><p>a.discard(999)   #删除一项，不存在不会报错</p></blockquote><blockquote><p>a.issubset(b)      #a是否是b的子集</p></blockquote><blockquote><p>a.issuperset(b)    #a是否是b的父集</p></blockquote><p><strong>三、例子（校验密码是否包含大写字母、小写字母、数字、特殊字符）</strong></p><pre><code>all_nums = set(string.digits)lower = set(string.ascii_lowercase)upper = set(string.ascii_uppercase)punctuation = set(string.punctuation)for i in range(5):   pwd = input(&apos;请输入你的密码：&apos;).strip()   pwd = set(pwd)   if pwd &amp; all_nums and pwd &amp; lower and pwd &amp; upper and pwd &amp; punctuation:      print(&apos;密码合法&apos;)   else:      print(&apos;密码不合法！&apos;)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、集合的介绍&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;集合天生去重&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;集合也是无序的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;集合的作用主要是关系测试，测试两组数据之前的交集，差集，并集,子集，父集，对称（反向）差集等关
      
    
    </summary>
    
      <category term="python" scheme="https://linbaobaodeyu.github.io/categories/python/"/>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Python的文件读写、Json模块</title>
    <link href="https://linbaobaodeyu.github.io/2018/06/18/Python%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E3%80%81Json%E6%A8%A1%E5%9D%97/"/>
    <id>https://linbaobaodeyu.github.io/2018/06/18/Python的文件读写、Json模块/</id>
    <published>2018-06-18T02:13:39.000Z</published>
    <updated>2019-03-25T08:53:15.975Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、打开文件的几种模式</strong></p><ol><li>使用open()函数打开文件，创建一个file对象，例如：f = open(r’D:\haha.txt’,’a+’,encoding=’utf-8’)      或    with open(r’D:\haha.txt’,’a+’,encoding=’utf-8’) as f  –该种写法不用关闭文件，用完自动关闭</li></ol><p>文件路径前加’r’是防止字符转义的，如果路径中出现’\t’的话，不加r的话\t就会被转义 ，而加了’r’之后’\t’就能保留原有的样子</p><ol start="2"><li><p>几种模式（最常用的是a+）：</p><p> ‘r’: 默认值，表示从文件读取数据，文件不存在会报错，指针在文件的开头</p><p> ‘r+’:打开一个文件用于读写，文件指针将会放在文件的开头。</p><p> ‘w’:打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</p><p> ‘w+’:打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</p><p> ‘a’:打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</p><p> ‘a+’: 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</p></li></ol><p><strong>二、几个方法</strong></p><blockquote><p>f.seek(0)    #将指针的位置移动到开头，例如追加模式下要读取文件</p></blockquote><blockquote><p>f.read()     #读取文件里面所有的内容，字符串</p></blockquote><blockquote><p>f.readline()   #读取一行</p></blockquote><blockquote><p>f.readlines()  #读取文件里的所有内容，返回的是一个list，每一行的内容就作为一个元素在list里面</p></blockquote><blockquote><p>f.write()     #写一个字符串到文件</p></blockquote><blockquote><p> f.writelines(list)  #写一个list，将list里的元素作为一行写入在文件里</p></blockquote><blockquote><p>f.close()   #关闭文件</p></blockquote><blockquote><p>f.flush()   #把缓冲区的数据立即写在磁盘上</p></blockquote><blockquote><p>f.truncate()  #清空文件内容</p></blockquote><blockquote><p>f.tell()       #获取当前文件指针的位置</p></blockquote><p>三、文件修改的高效处理方式</p><p>思路：</p><p>1、先打开原来的文件，再打开一个空文件</p><p>2、循环处理原来文件里面每一行数据，处理完之后，写到新文件里面</p><p>3、把原来的文件删除，把新文件的名字改成原来文件的名字</p><p>例子：</p><pre><code>import oswith open(&apos;words&apos;,encoding=&apos;utf-8&apos;) as fr, open(&apos;.words&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as fw:   for line in fr:      line = line.lstrip()  #去掉左边的空格      if line:#判断这一行是否有数据         line = line.replace(&apos;你&apos;,&apos;you&apos;)#替换数据         fw.write(line)#写到新文件里面</code></pre><p>os.remove(‘words’)#删除原来的文件<br>os.rename(‘.words’,’words’) #把新文件的名字改成原来文件的名字</p><p>四、Json模块</p><pre><code>import Jsonjson.loads(user_info)    #把json串（字符串）转成字典json.load(f)     #这个是直接从文件里拿，不需要再读一次文件了，json帮你读，转成字典了json.dumps(stu_info)      #把字典转成json（字符串）json.dump(stu_info,f,ensure_ascii=False,indent=4)   </code></pre><ol><li>不需要咱们自己再write了，人家会转成json写入到文件  </li><li>#ensure_ascii=False 解决了中文写入文件后乱码问题</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、打开文件的几种模式&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用open()函数打开文件，创建一个file对象，例如：f = open(r’D:\haha.txt’,’a+’,encoding=’utf-8’)      或    with open
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Python的元组、列表截取</title>
    <link href="https://linbaobaodeyu.github.io/2018/06/17/Python%E7%9A%84%E5%85%83%E7%BB%84%E3%80%81%E5%88%97%E8%A1%A8%E6%88%AA%E5%8F%96/"/>
    <id>https://linbaobaodeyu.github.io/2018/06/17/Python的元组、列表截取/</id>
    <published>2018-06-17T13:40:06.000Z</published>
    <updated>2019-03-25T08:53:15.975Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、元组介绍</strong></p><ol><li><p>Python的元组与列表类似，不同之处在于元组的元素不能修改。</p></li><li><p>元组使用小括号，列表使用方括号。例如：tup = (1, 2, 3, 4, 5 );</p></li><li><p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p></li><li><p>元组中只包含一个元素时，需要在元素后面添加逗号。</p></li><li><p>元组与字符串类似，下标索引从0开始，可以进行截取，组合等。</p></li></ol><p><strong>二、元组的用法</strong></p><ol><li><p>取值（使用下标）</p><p> tup1[0]</p><p> tup2[1:5]  #顾头不顾尾，取得是下标1到下标4的元素</p></li><li><p>修改，元组中元素不可修改，但是可以对元组进行连接组合</p><p> tup3 = tup1 + tup2;</p></li><li><p>删除：del tup</p></li><li><p>将列表转换为元组： tuple(list)</p></li></ol><p><strong>三、切片（列表、字符串、范围取值的一种方法）</strong></p><ol><li><p>list[:3]     #顾头不顾尾,如果开始的下标不写的话，那么就是从最前面开始</p></li><li><p>list[-1]    #-1代表最后一个元素</p></li><li><p>list[1:]     #如果下标不写的话，代表取到最后</p></li><li><p>list[:]      #开头的下标和结尾的下标都不写的话，代表取整个list</p></li><li><p>list[-6:-10:-1]   #第二个冒号后面值代表步长，是隔几个元素取一次，步长是负数的话，从右往左开始取值</p></li><li><p>list[::-1]       #将列表里的元素都取出来了，但是顺序是之前的倒过来，因为步长是负数</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、元组介绍&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Python的元组与列表类似，不同之处在于元组的元素不能修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;元组使用小括号，列表使用方括号。例如：tup = (1, 2, 3, 4, 5 );&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Python的字典</title>
    <link href="https://linbaobaodeyu.github.io/2018/06/17/Python%E7%9A%84%E5%AD%97%E5%85%B8/"/>
    <id>https://linbaobaodeyu.github.io/2018/06/17/Python的字典/</id>
    <published>2018-06-17T03:12:57.000Z</published>
    <updated>2019-03-25T08:53:15.975Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、字典的介绍</strong></p><ol><li><p>字典是另一种可变容器模型，且可存储任意类型对象。</p></li><li><p>字典的每个键值 key-value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示：</p><p> d = {key1 : value1, key2 : value2 }</p></li><li><p>字典是无序的</p></li><li><p>字典里的key是唯一的，如果key已有，就覆盖key对应得值，如果key不存在，则插入一条键值对</p></li><li><p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组</p></li></ol><p><strong>二、字典的用法</strong></p><pre><code>data = { &apos;name&apos;:&apos;张三&apos;,　　　　&apos;age&apos;:18,　　　　&apos;sex&apos;:&apos;女&apos;}</code></pre><ol><li><p>增加</p><p> data[‘email’]<a href="mailto:=&#39;1000000@qq.com" target="_blank" rel="noopener">=&#39;1000000@qq.com</a>‘</p><p> data.setdefault(‘age’,49)     #setdefault这种方式，如果key已经存在，不管它，如果key不存在的话，就新增</p></li><li><p>修改</p><p> data[‘sex’]=’男’</p></li><li><p>删除</p></li></ol><p>data.pop(‘sex’)  #指定的key来删除，key不存在会报错</p><p>del  data[‘sex’]   #指定的key来删除，key不存在会报错</p><ol start="4"><li><p>取值</p><p> data[‘sex’]  </p><p> data.get(‘sex1’,’haha’)    #返回指定键的值，如果值不在字典中返回default值(‘haha’)</p></li><li><p>其他</p></li></ol><p>data.clear()   #清空字典</p><p>data.update(data2)  #把字典2的键值对加入到字典里</p><p>data.items()  #以列表返回可遍历的(键, 值) 元组数组</p><p>data.keys()  #以列表返回一个字典所有的键</p><p>data.valus #以列表返回一个字典所有的值</p><p>data.popitem() #随机返回并删除字典中的一对键和值</p><ol start="6"><li><p>高效循环字典的方式：</p><p> for k  in data:</p><p>   print(k,data.get(k))</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、字典的介绍&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;字典是另一种可变容器模型，且可存储任意类型对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字典的每个键值 key-value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>python的数据类型、数组、条件判断、循环的基础知识</title>
    <link href="https://linbaobaodeyu.github.io/2018/06/17/python%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E3%80%81%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://linbaobaodeyu.github.io/2018/06/17/python的数据类型、数组、条件判断、循环的基础知识/</id>
    <published>2018-06-17T02:25:14.000Z</published>
    <updated>2019-03-25T08:53:15.976Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、数据类型</strong></p><p>最常见的数据类型有：整型（int），浮点型（float），字符串（strs）。例如: #整型 a=8   #浮点型 b=8.0  #字符串 c=’hello world’。</p><p>数据类型的转换：不同数据类型的变量无法做比较或运算，需要转换后才可，查看变量a的数据类型，使用print(type(a))。例如: #字符串转整型   a=’1’  a =int(a)   #整型转字符串 a=1 a=str(a)  #整型转浮点型  a=1 a=float(1)  浮点型四舍五入可以用round函数  。</p><p>占位符的使用：有时候打印一句话包含了几个变量拼接，中间用加号连接较麻烦，就可以使用占位符。例如：%s 字符串 %d 整数 %f 就是小数 </p><p>msg = ‘欢迎%s登录，今天是%s’  %(user,today)</p><p><strong>二、列表（数组）</strong></p><p>数组有一维数组，多维数组，数组的下标从0开始。数组的增删改查，例子：</p><p>list=[‘a’,’b’,’c’]   </p><blockquote><p>增加（在列表的末尾增加一个元素） list.append(‘d’)    运行结果：[‘a’,’b’,’c’,’d’] </p></blockquote><blockquote><p>增加（在指定位置增加一个元素）list.insert(2,’d’)    运行结果：[‘a’,’b’,’d’,’c’]</p></blockquote><blockquote><p>删除（删除指定位置的元素） list.pop (2)   或  del  list[2]   运行结果：[‘a’,’b’]</p></blockquote><blockquote><p>删除（删除指定的元素）list.remove(‘a’)  运行结果：[‘b’,’c’]  </p></blockquote><blockquote><p>删除（清空整个list）list.clear()</p></blockquote><blockquote><p>改  list[0]=’a1’ 运行结果：[‘a’1,’b’,’c’]  </p></blockquote><blockquote><p>查  list[-1] 当下标为-1时就取最后一个元素    list.count(‘a’) 是统计a这个元素在list里出现了几次</p></blockquote><p>其他用法    list.count(‘a’) 是统计a这个元素在list里出现了几次 ， list.index(‘a’)是返回a这个元素第一次出现的下标 ，  list.reverse()是反转，数组里的元素反过来排列，</p><p>list1.extend(list2)是把list2的元素加到list1里面  ， list.sort(reverse=True) 将list里元素降序排列，不带reverse=True就是默认的升序排列</p><p>多维数组：my=[[1,2,3,4,5,6],[‘name’,’age’,’sex’,’哈哈’,[‘小明’,’小黑’,’小白’]],890]  </p><p>print(my[1][4][0])      运行结果：小明</p><p>my[1][4].append(‘小紫’)    运行结果：[[1, 2, 3, 4, 5, 6], [‘name’, ‘age’, ‘sex’, ‘哈哈’, [‘小明’, ‘小黑’, ‘小白’, ‘小紫’]], 890]</p><p>my[1][2]=’性别’   运行结果：[[1, 2, 3, 4, 5, 6], [‘name’, ‘age’, ‘性别’, ‘哈哈’, [‘小明’, ‘小黑’, ‘小白’]], 890]</p><p><strong>三、条件判断</strong></p><p>python条件判断基本上就是if-elif-else，例子：</p><p>if score&gt;=90:<br>   print(‘你很优秀’)<br>elif score<90 and="" score="">=80:<br>   print(‘良好’)<br>elif score<80 and="" score="">=60:<br>   print(‘及格’)<br>else:<br>   print(‘不及格’)<br><strong>四、循环</strong></80></90></p><p>循环就是重复执行循环体里的代码，python里循环有while循环跟for循环。while循环必须有一个计数器。</p><p>例子1（while循环）：</p><pre><code>import randomnum = random.randint(1,100)#产生一个随机的数字count = 0while count&lt;7:   guess = input(&apos;请输入你的猜的数字：&apos;)   guess = int(guess)   if guess&gt;num:      print(&apos;大了&apos;)   elif guess&lt;num:      print(&apos;猜小了&apos;)   else:      print(&apos;恭喜你猜对了&apos;)      break       #立即结束整个循环，最下面的else都不会执行   count=count+1else:#循环正常结束之后，会执行else   print(&apos;游戏次数已经用尽，请充值&apos;)</code></pre><p>例子2（for循环）：</p><pre><code>num = 10for i in range(3): #循环三次   guess = input(&apos;请输入你的猜的数字：&apos;)   guess = int(guess)   if guess &gt; num:      print(&apos;大了&apos;)   elif guess &lt; num:      print(&apos;猜小了&apos;)   else:      print(&apos;恭喜你猜对了&apos;)      break  # 立即结束循环else:  #循环正常结束之后执行的   print(&apos;游戏次数用完了&apos;)</code></pre><p>注意循环里break与continue的使用，break是立即结束整个循环，而continue是结束本次循环，进入下一次循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最常见的数据类型有：整型（int），浮点型（float），字符串（strs）。例如: #整型 a=8   #浮点型 b=8.0  #字符串 c=’hello world’。&lt;/p&gt;
&lt;p&gt;数据类型的转换：不同数据
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Python的字符串常用方法</title>
    <link href="https://linbaobaodeyu.github.io/2018/06/17/Python%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://linbaobaodeyu.github.io/2018/06/17/Python的字符串常用方法/</id>
    <published>2018-06-17T02:25:11.000Z</published>
    <updated>2019-03-25T08:53:15.975Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、字符串常用方法</strong></p><p>str.capitalize()      #字符串首字母大写</p><p>str.center(20,’-‘)   #把字符串居中，两边以’-‘填充，长度一共为20</p><p>str.index(‘p’)       #返回字符’p’在字符中的下标，找不到下标时会报错</p><p>str.isalnum()     #判断字符串里只能有英文、数字 ，返回布尔值</p><p>str.isalpha()     #判断是否只为英文的，汉字也可以</p><p>str.count(‘a’)    #返回’a’字符在字符串中的个数</p><p>str.endswith(‘.jpg’)    #判断字符串是否以xx结尾</p><p>str.startswith(‘138’)   #判断字符串是否以xx开头</p><p>str.upper()    #字母都给变成大写的</p><p>str.lower()  #字母都给变成小写的</p><p>str.find(‘p’)   #返回字符’p’在字符中的下标，找不到时就返回-1</p><p>str.isdigit()  #判断是否为纯数字</p><p>str.isspace()  #判断是否全都是空格</p><p>str.strip()   #去掉字符串两边的东西,默认是去掉两边的空格和换行符的</p><p>str.lstrip()  #只去掉左边的空格跟换行符</p><p>str.rstrip()  #只去掉右边的空格跟换行符</p><p>str.replace(‘a’,’b’)   #替换字符串，把前面的a替换成后面的b</p><p>str.zfill(2)     #在前面补0，补到长度为2</p><p><strong>str.split(‘,’)    #1.以‘,’分割字符串 2.将字符串变成一个list  3.默认是以空格跟换行符分割的</strong></p><p><strong>‘\n’.join(stus)   #1.将数组元素以换行符\n来拼接成字符串  2.将list变成字符串   3.以某个字符串连接</strong></p><p>str[1]  #字符串也可以根据下标来取值</p><p>str.format()  #字符串的格式化</p><p><strong>二、String模块</strong></p><p>import String</p><p>string.ascii_letters  #所有的大写+小写字母</p><p>string.ascii_lowercase  #所有的小写字母</p><p>string.ascii_uppercase  #所有的大写字母</p><p>string.digits  #所有的数字</p><p>string.punctuation  #所有的特殊字符</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、字符串常用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;str.capitalize()      #字符串首字母大写&lt;/p&gt;
&lt;p&gt;str.center(20,’-‘)   #把字符串居中，两边以’-‘填充，长度一共为20&lt;/p&gt;
&lt;p&gt;str.index(‘
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>抓包工具之Charles的基本使用</title>
    <link href="https://linbaobaodeyu.github.io/2018/05/27/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E4%B9%8BCharles%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://linbaobaodeyu.github.io/2018/05/27/抓包工具之Charles的基本使用/</id>
    <published>2018-05-27T15:25:57.000Z</published>
    <updated>2019-03-28T03:23:55.528Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、网页抓包</strong></p><p>安装好charles工具后打开，点击菜单Proxy下面的Windows Proxy为勾选上，将charles设置为系统代理。如下所示：<br><img src="/2018/05/27/抓包工具之Charles的基本使用/1405370-20180527223141679-1977393369.png" alt="img"><br>接下来，在Structure和Sequence两个页签下看到自己电脑通过浏览器发的请求信息啦。Structure是按照 访问的域名分类，而Sequence是按照请求访问的时间排序。如果是https请求，需要安装CA证书文件。</p><p><strong>二、手机抓包</strong></p><p>首先设置charles，点击菜单栏Proxy，选择Proxy Settings，端口默认是8888，可以不用更改，勾选上Enable transparent HTTP proxying。然后查看自己运行charles电脑的IP地址。接下来再操作手机，前提是电脑与手机在同一个局域网内，点击手机上连接的wifi，点击配置代理，勾选为手动，服务器IP填写为刚刚查看的电脑IP，端口为8888。再点击手机上任何一个软件或浏览器访问，在charles上会弹出一个手机请求连接的提示框，点击允许就可以了，在charles上就可以看到手机上的请求了。</p><p><strong>三、过滤</strong></p><p>在 Charles 的菜单栏选择 Proxy-&gt;Recording Settings，然后选择 Include 栏，选择Add，然后填入需要监控的协议，主机地址，端口号,这样就达到了过滤的目的。或者在Sequence理的Filter里填写需要过滤到的Host的。</p><p><strong>四、模拟弱网络</strong></p><p>有时候在测试手机app时需要模拟网速慢的情况，在charles上设置，在Proxy-&gt;Throttle Setting，然后选择Enable Throttling，在Throttle Preset下选择网络类型即可，如下所示：<br><img src="/2018/05/27/抓包工具之Charles的基本使用/1405370-20180527230223370-1262519208.png" alt="img"><br>如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。</p><p><strong>五、修改网络请求</strong></p><p>选中请求后，点击菜单栏的编辑按钮，即可编辑请求，然后再点击Execute就可以重发该请求了。如下所示：<br><img src="/2018/05/27/抓包工具之Charles的基本使用/1405370-20180527230929636-1835040041.png" alt="img"><br>六、断点</p><p> 可以给charles抓到的请求设置断点，来观察或修改发送或者返回的响应信息，要针对某一个请求设置断点，只需要在这个请求网址右击选择Breakpoints，然后点击断点按钮，就可以断点某一个请求了。如下所示：<br><img src="/2018/05/27/抓包工具之Charles的基本使用/1405370-20180527231409260-1467702983.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、网页抓包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装好charles工具后打开，点击菜单Proxy下面的Windows Proxy为勾选上，将charles设置为系统代理。如下所示：&lt;br&gt;&lt;img src=&quot;/2018/05/27/抓包工具之Charles的
      
    
    </summary>
    
      <category term="学习" scheme="https://linbaobaodeyu.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="随笔" scheme="https://linbaobaodeyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="charles" scheme="https://linbaobaodeyu.github.io/tags/charles/"/>
    
      <category term="网页抓包" scheme="https://linbaobaodeyu.github.io/tags/%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>接口测试之Postman、Jmeter的使用（一）</title>
    <link href="https://linbaobaodeyu.github.io/2018/05/22/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E4%B9%8BPostman%E3%80%81Jmeter%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://linbaobaodeyu.github.io/2018/05/22/接口测试之Postman、Jmeter的使用/</id>
    <published>2018-05-22T14:54:05.000Z</published>
    <updated>2019-03-28T03:28:01.144Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、接口测试</strong></p><p>接口测试就是通过接口文档上的调用地址、请求参数、拼接报文，然后发送请求，检查返回结果。通过接口测试可以早期在功能测试之前发现很多Bug，减少了成本，也可以检查系统的异常处理情况、安全性、稳定性等。</p><p><strong>二、Get请求与Post请求的区别</strong></p><ol><li><p>Get使用URL或Cookie传参，而Post将数据放在Body中。（Cookie是维护用户在线状态的，Cookie是存放在用户本地的一个键值对，而session是对应存放在服务器上的一个键值对）</p></li><li><p>Get有长度限制，而Post的数据可以非常大。</p></li><li><p>一般Get请求用来获取数据，而Post请求用来发送数据。</p></li></ol><p><strong>二、Postman的使用</strong></p><ol><li>传参是json类型</li></ol><p>点击Body后，选择Raw，最后面默认的text类型换成Json类型</p><ol start="2"><li>文件上传</li></ol><p>点击Body后，key输入框里面的默认的Text换成File类型，然后可选择文件了</p><p><strong>三、Jmeter的使用</strong></p><ol><li><p>查看结果树乱码</p><p>在jmeter的bin目录下找到jmeter.properties这个文件，添加上sampleresult.default.encoding=utf-8</p></li><li><p>body data里面有乱码</p><p>在jmeter的bin目录下找到jmeter.properties这个文件，添加上jsyntaxtextarea.font.family=Hack</p></li><li><p>Jmeter参数化的几种方式</p><p>a.用户定义的变量</p><p>b.函数助手（_Random，_time）</p><p>c.CSV Data Set Config</p></li><li><p>请求的关联关系处理</p><p>a.处理响应为Json类型的，可添加Json的插件，Json Path Extractor</p><p>例子：</p></li></ol><p><img src="/2018/05/22/接口测试之Postman、Jmeter的使用/1553743679046.png" alt="1553743679046"></p><p> b.正则表达式</p><ol start="5"><li><p>操作数据库mysql</p><p>a.导入jdbc的jar包（测试计划最下面的浏览选择jar包）</p><p>b.JDBC Connection Configuration配置</p><p>①.添加数据库连接池的名称，后面发sql请求指定连接哪里（Variable Name Bound to Pool）</p><p>②.Data Base Url:  jdbc:mysql://host:port/dbname?characterEncoding=utf8&amp;allowMultiQueries=true</p><p>③.JDBC Driver Class:com.mysql.jdbc.Driver</p><p>④.账号、密码</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、接口测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接口测试就是通过接口文档上的调用地址、请求参数、拼接报文，然后发送请求，检查返回结果。通过接口测试可以早期在功能测试之前发现很多Bug，减少了成本，也可以检查系统的异常处理情况、安全性、稳定性等。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="学习" scheme="https://linbaobaodeyu.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="接口测试" scheme="https://linbaobaodeyu.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
      <category term="get请求" scheme="https://linbaobaodeyu.github.io/tags/get%E8%AF%B7%E6%B1%82/"/>
    
      <category term="post请求" scheme="https://linbaobaodeyu.github.io/tags/post%E8%AF%B7%E6%B1%82/"/>
    
      <category term="Postman" scheme="https://linbaobaodeyu.github.io/tags/Postman/"/>
    
      <category term="Jmeter" scheme="https://linbaobaodeyu.github.io/tags/Jmeter/"/>
    
      <category term="正则表达式" scheme="https://linbaobaodeyu.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
