<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python之面向对象编程]]></title>
    <url>%2F2018%2F07%2F31%2FPython%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、类的对象、实例化、变量 概念：类就是class,将一类事物放到一起，类里面包含这类事物的各种函数方法，相当于一个模型，例如造汽车，造汽车就是一个类，类里面包含造轮胎，造车门等函数方法。类的实例化就是通过这个类，这个模型造出来的实际的东西，例如通过造汽车这个模型造出来了一个汽车，这个汽车就是这个类的一个实例。在类里面有类变量，写在类里面，函数外面，通常就是类变量，在函数里面类似于self.name 这种就是实例变量。类的对象在代码层指的就是self，在函数里都会默认有个参数为self，类里面的函数都是面向这个self对象，函数里面的self.name 这种变量也是的，所以在一个类的函数里面，各个函数可以直接调用类里的其他函数的self.name 这种变量，或是self.函数名这个函数。其实在实例化的时候就是将那个实例传递给这个类里面的self，所以这个实例会拥有这个类里面的所有属性，或是方法。 例子： 123456789101112class Person: #类,类名都以大写字母开头，驼峰式取名 country = 'China' #类变量 def say(self): self.name = '张三' #实例变量 def cry(self): print('%s 哇哇哇'%self.name) #调用上一个函数里self.name self.say() #调用函数say()a=Person() #类的实例化a.cry() #实例化后，相当于类里面的self变成了aPerson.country #类变量可直接类.变量名 使用 二、实例方法、类方法、静态方法、属性方法 概念： 实例方法：正常定义的函数都是实例方法，函数后默认参数self 类方法（方法名上一行加装饰器@classmethod）： a.可以不实例化，直接用类名调用，类名.函数名()，也可以实例化，实例化后也可以直接通过实例名.函数名()来使用类方法 b.它可以使用类变量，cls.变量名 c.在实例方法里，可以使用self.函数名()，来使用类方法 d.在类方法里，它是不能用这些实例方法和实例变量，类似于self.xx这种 静态方法（方法名上一行加装饰器@staticmethod）： a.就是一个普通的函数，只是定义在类里面而已 b.用不了实例方法、用不了实例变量、也用不了类方法、类变量 c.也不需要实例化，直接类名.方法名()调用即可 属性方法(方法名上一行加装饰器@property)： a.看起来像变量的一个函数 b.是个实例方法 c. 它不能有入参 d.用它的时候，直接实例名.函数名，把它当做一个变量用就ok了，不需要加括号调用 e.它是获取函数的返回值，return的值 例子： 1234567891011121314151617class My: country ='China'def say(self): #实例方法 print('实例方法') self.eat() #调用类方法@classmethod #类方法def eat(cls): #class，不是self print(cls.country) #使用类变量 print('类方法') cls.run() #调用静态方法@staticmethod #静态方法def run(): print('静态方法')@property #属性方法def red_pag(self): return 100 三、构造函数、析构函数 概念： 构造函数：构造函数，类在实例化的时候，会自动执行它 析构函数：析构函数，这个实例被销毁的时候自动执行的 例子： 1234567def __init__(self): #构造函数 print('构造函数，类在实例化的时候，会自动执行它') self.__client = pymongo.MongoClient(host='xxxxxx',port=xxx) #类似于连接数据库的可以放在构造函数里，在实例化时就连一次连上def __del__(self): #析构函数 print('析构函数，这个实例被销毁的时候自动执行的') self.__client.close() #类似于关闭数据库连接的可以放在析构函数里 四、继承、私有 私有：函数名或者变量名前面加__，这个函数或者变量就是私有的，私有只能在类里面用。 例子：def cry(self): #私有函数，只能类里面用，在类里面的其他函数里可通过self.xx调用到该函数，但是在类外或是实例的时候无法调用到该函数 print(‘私有’) 继承：继承就是一个类继承了另一个类后，会拥有另一个类的属性，例如变量或函数，但是如果在本类里有相同名称的方法或变量，优先于是本类，不会再去父类找。 123456789101112131415161718192021222324例子1：class Father: #父类 money = '2000' def make_money(self): print('挣钱')class Son(Father): #子类 passa=Son()a.make_money() #调用到父类的函数print(a.money) #调用到父类的变量例子2：class One: #父类 def say(self): print('one')class Two(One): #子类，继承父类One def say(self,name): super().say() #执行父类方法，如果想不更改继承的父类方法下，又在父类方法上新增功能，则super().函数名()就是执行相应的父类方法 print('%sTwo' %name)b=Two()b.say('yuze')]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>测试</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python之网络编程（requests模块）]]></title>
    <url>%2F2018%2F07%2F29%2FPython%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88requests%E6%A8%A1%E5%9D%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、requests模块的基本方法 import requests res = requests.get(url,params={‘stu_name’:’小黑’}) #发送get请求,传参k-v形式 data={‘user’:’useraccount’,’pwf’:’password’} res = requests.post(url,data=data) #发送post请求，传参k-v形式 data={“name”:”requests_name”,”grade”:”天蝎座”} res = requests.post(url,json=data) #发送post请求，入参是json类型的 cookie = {‘zhangsan’:’abd9a0995f4696e1a60133220b32037a’} res = requests.post(url,data=data,cookies=cookie) #发送post请求，带cookie的 header = {‘Referer’:’http://api.nnzhp.cn/&#39;} res=requests.get(url,headers=header) #发送get请求，带header的 res = requests.get(url,verify=False) #发送https请求，需加上verify=False res.json() #把返回的结果转成字典，必须返回是json res.text #返回成字符串 res.content #用来下载文件用的，返回的是二进制 res.headers #获取到返回的所有header res.cookies #获取到返回的所有cookie res.status_code #获取到请求响应的状态码 二、例子 例子一（下载图片）： url6=&apos;https://aliimg.changba.com/cache/photo/855e5493-f018-44db-8892-c8660649327b_640_640.jpg&apos; res = requests.get(url6,verify=False) #verify=False如果是https的话加上这个 with open(&apos;tu.jpg&apos;,&apos;wb&apos;) as fw: #打开一个文件 fw.write(res.content) #将请求获取到的结果写入到文件里去，是文件，所以是res.content二进制 例子二（获取qq群的成员信息存入到mongodb里以及下载成员的头像保存到本地）： import pymongo,os client = pymongo.MongoClient(host=&apos;x.x.x.x&apos;,port=xxxx) db=client[&apos;qq_group&apos;] table = db[&apos;xxx&apos;] url = &quot;https://qun.qq.com/cgi-bin/qun_mgr/search_group_members&quot; data = {&quot;gc&quot;:xxxxx,&quot;st&quot;:0,&quot;end&quot;:200,&quot;sort&quot;:0,&quot;bkn&quot;:xxxxxxx} header = {&quot;Cookie&quot;:&quot;pgv_pvi=1977809920; tvfe_boss_uuid=d8ce464d0b7bd6f6; RK=6RFHD8oPOz; ptcz=11c139fb4d425800954a94bcb78d8b04222ef05985e6b9ac493a28744decc178; pgv_pvid=744932512; ptui_loginuin=2851662269; o_cookie=2851662269; pt2gguin=o0469873580; uin=o0469873580; ptisp=ctc; pgv_si=s8086261760; skey=@LfPHQ7sb0; p_uin=o0469873580; pt4_token=sf7OadX0vT5Mv4PiIQ3xkHbiI9quA5GB75z8lMcLgag_; p_skey=PcX00u1AVFRWKu6N1S62ooT13P*JDcCOhq64nknIlGQ_&quot;} res = requests.post(url=url,data=data,headers=header) mems = res.json().get(&quot;mems&quot;)#获取到该群的所有成员的信息 for i in mems: mem = { &quot;qq&quot;:i.get(&quot;uin&quot;), &quot;gender&quot;:i.get(&quot;g&quot;), &quot;nick&quot;:i.get(&quot;nick&quot;), &quot;card&quot;:i.get(&quot;card&quot;), &quot;qage&quot;:i.get(&quot;qage&quot;) } if mem.get(&quot;gender&quot;) == 0: mem[&apos;gender&apos;] = &quot;男&quot; elif mem.get(&quot;gender&quot;) == 1: mem[&apos;gender&apos;] = &quot;女&quot; else: mem[&apos;gender&apos;] = &quot;未知&quot; if mem.get(&quot;card&quot;) == &quot;&quot;: mem[&apos;card&apos;] = &quot;没有群名片&quot; table.insert_one(mem) qq = mem.get(&quot;qq&quot;) url= &quot;http://q4.qlogo.cn/g?b=qq&amp;nk={}&amp;s=140&quot;.format(qq) pics = requests.get(url) abs_path=os.path.join(&apos;pics&apos;,str(qq)+&apos;.jpg&apos;) #拼接路径，都把图片保存到一个文件夹下面 with open(abs_path,&quot;wb&quot;) as f: f.write(pics.content) print(&apos;%s的头像已经下载完成.&apos;%mem.get(&quot;nick&quot;))]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>requests</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python之异常处理]]></title>
    <url>%2F2018%2F07%2F29%2FPython%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、异常处理 通常在写程序的时候会预知一些程序可能发生的异常做判断，但是又不可能全面，例如sql语句错误，有很多种又不可能都写出来，而程序在发生异常报错的时候，代码会终止，不会往下执行，这种时候我们就需要进行异常处理，让程序遇到异常能抛出，并且能正常执行后面的代码。 二、例子 money = 1000num = input(‘plese enter a num:’)try: num = float(num) res = money/numexcept Exception as e: #出现异常了，就走except下面的代码 print(‘出现异常了’) print(‘你输入的价格不合法。。’) print(e) #打印出异常信息else: #没有出现异常，执行下面代码 money-=num print(num) print(‘你的余额是%s’%money)finally: #程序最后一定会执行的，无论是否出现异常 print(‘我是finally’)]]></content>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之操作mysql、redis、mongodb]]></title>
    <url>%2F2018%2F07%2F19%2Fpython%E4%B9%8B%E6%93%8D%E4%BD%9Cmysql%E3%80%81redis%E3%80%81mongodb%2F</url>
    <content type="text"><![CDATA[一、操作mysql import pymysql def my_db(ip,user,passwd,db,sql,port=3306,charset=&apos;utf8&apos;): coon = pymysql.connect(host=ip,user=user, password=passwd,db=db, port=port,charset=charset,autocommit=True) cur = coon.cursor() #建立游标 sql=sql.strip() cur.execute(sql) #执行sql语句，但不会返回执行的结果 sql_start = sql[:6].lower()#取sql的开头,转成小写 if sql_start.startswith(&apos;select&apos;) or sql_start.startswith(&apos;show&apos;): data = cur.fetchall() #获取到查询的所有结果 else: data = &apos;ok&apos; cur.close() #关闭游标 coon.close() #关闭连接 return data 二、操作redis import redis r = redis.Redis(host=&apos;x.x.x.x&apos;,port=6379,password=&apos;xxx&apos;,db=10) #1.操作string类型 r.set(&apos;a&apos;,&apos;age18&apos;) #增加、修改数据 res = r.get(&apos;111&apos;) #获取数据 r.delete(&apos;nhy_info&apos;) #指定一个key删除 res.decode() #编码，就变成了字符串 r.keys(&apos;*info&apos;) #获取到所有的key r.exists(&apos;dashu_name&apos;)) #判断这个key是否存在 r.flushdb()#可以清空当前数据库里面所有的key r.expire(&apos;session_crm&apos;,600)#指定key的失效时间，秒为单位 r.ttl(&apos;session_crm&apos;))#用来看这个key的失效时间 def op_redis_str(k,t=None,v=None): r = redis.Redis(**REDIS_INFO) if v and t==None: r.set(k,v) elif v and t: r.set(k,v) r.expire(k,t) elif v==None: res=r.get(k) if res==None: return None else: return res.decode() ###2.操作hash类型 r.hset(‘session_crm’,’liuxinyu’,’sdfjksdklfjssdf’) #增加、修改（大k,小k，值） r.hdel(‘session_crm’,’liuxinyu’) #删除指定的小key r.delete(‘session_crm’) #直接删除大key r.hget(‘session_crm’,’zhouyifan_’) #获取指定小key里面的数据 res = r.hgetall(‘session_crm’)#获取到hash类型里面所有的数据 def op_hash(k1, k2=None, v=None): if v and k2: r.hset(k1,k2,v) elif v==None and k2==None: res2=r.hgetall(k1) for k, v in res2.items(): res2[k.decode()]=res2.pop(k).decode() return res2 elif v==None and k2: res3=r.hget(k1,k2) return res3.decode()三、操作mongodb import pymongo client = pymongo.MongoClient(host=&apos;x.x.x.x&apos;,port=27017) db = client[&apos;szp&apos;] #选择数据库，如果这个数据库不存的话，会帮你创建 collection = db[&apos;stu_info&apos;] #选择一个集合，就相当于mysql里面表 db[&apos;stu_info&apos;].insert({&apos;url&apos;:&apos;http://www.baidu.com&apos;,&apos;title&apos;:&apos;baidu.com&apos;,&apos;addr&apos;:&apos;西二旗&apos;}) for d in db[&apos;stu_info&apos;].find({&apos;title&apos;:&apos;baidu.com&apos;}): print(d) collection.delete_one({&apos;title&apos;:&apos;baidu.com&apos;}) #如果有多条的话，只会帮你删掉1条 collection.delete_many({&apos;title&apos;:&apos;baidu.com&apos;})#会删除多条 print(list(collection.find())) collection.update({&apos;jd&apos;:&apos;www.jd.com&apos;},{&apos;jd&apos;:&apos;www.jd.com&apos;,&apos;addr&apos;:&apos;亦庄&apos;})]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>测试</tag>
        <tag>mysql</tag>
        <tag>redis</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python之操作excel]]></title>
    <url>%2F2018%2F07%2F16%2FPython%E4%B9%8B%E6%93%8D%E4%BD%9Cexcel%2F</url>
    <content type="text"><![CDATA[一、写excel import xlwt book=xlwt.Workbook() #创建excel sheet=book.add_sheet(&apos;sheet1&apos;) #加一个sheet sheet.write(0,0,&apos;学生编号&apos;) #行，列，数据 for index,line_data in enumerate(data): #使用枚举，循环写数据到excel for index2,col_data in enumerate(line_data): sheet.write(index,index2,col_data) book.save(&apos;1.xls&apos;) #保存的后缀得是xls 二、读excel import xlrd book = xlrd.open_workbook(&apos;nhy.xls&apos;) book.nsheets #获取到excel里面总共有多少个sheet页 sheet = book.sheet_by_index(0) #按index来找sheet book.sheet_by_name(&apos;sheet1&apos;) #按name来找sheet sheet.cell(0,0).value #指定行和列，获取某个单元格里面的内容 sheet.row_values(0) #获取某一行的数据 sheet.nrows #这个就是excel里面总共有多少行 sheet.col_values(0) #获取某一列的数据 sheet.ncols #总共有多少列 三、修改excel import xlrd from xlutils import copy book1 = xlrd.open_workbook(&apos;nhy.xls&apos;) #打开原来的excel new_book = copy.copy(book1) #拷贝一个新的excel sheet = new_book.get_sheet(0) #获取第一个sheet页 sheet.write(1,3,&apos;王艳会&apos;) #改数据 new_book.save(&apos;nhy.xls&apos;) #命名为原来的excel]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的模块安装、导入]]></title>
    <url>%2F2018%2F07%2F16%2FPython%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E3%80%81%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[一、模块的安装 有网络的情况下： 直接在cmd里面，输入pip install xxx ，就是安装某个模块 无网络的情况下，下下来的安装包： .whl的后缀，pip install xxx.whl .tar.gz的后缀，解压后，进入模块文件夹，执行： python setup.py install 3.卸载：pip uninstall xxx 二、导入模块的顺序 第一步去当前目录下找这个python文件 第二步去python的环境变量里面找这个python文件 导入模块的实质就是把这个模块的代码，从头到尾的执行一次]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的模块（二）]]></title>
    <url>%2F2018%2F07%2F16%2FPython%E7%9A%84%E6%A8%A1%E5%9D%97%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、OS模块的补充 os.path.abspath(‘..\day3’) #取绝对路径（相对路径换绝对路径），路径会按照当前系统的方式， 一个点是当前目录， 两个点是上一级目录 os.listdir(e:\spz\day3) #获取目录下的文件 os.chdir(‘e:\spz\day3’) #更改当前工作目录 os.system(‘ipconfig’) #用来执行操作系统命令,但是只能帮你执行，获取不到结果 os.popen(‘ipconfig’).read() #用来执行操作系统命令，获取到执行后结果 二、datetime模块 datetime.date.today() #当天的日期，只有日期 datetime.datetime.today() #当天的时间，有日期有时间 datetime.date.today()+datetime.timedelta(days=-2) #取几天前或几天后的日期，-2就是取两天前的 res = datetime.datetime.today() + datetime.timedelta(hours=-10,minutes=-20) res.time() #只取到时间 res.date() #只取到日期 res.timestamp()) #时间戳 res.strftime(‘%Y-%m %H:%M:%S’) #取到格式化好的时间 三、random模块 random.random() #取小于1的随机的小数 random.randint(1,10)) #取随机整数，可指定范围，包含头尾的 random.choice(x)) #随机在x中选择一个，只选择一个 random.sample(x,9)) #随机在x中选择9个值，返回的是一个list random.uniform(8.5,8.8)) #指定一个范围，然后取一个随机小数 四、nnlog模块（写日志） my_log=nnlog.Logger(‘yuze.log’,when=’S’,backCount=5) #只保留5个日志文件，日志文件按日期到秒来 my_log.debug(‘这是debug的’) my_log.info(“info级别的”) my_log.warning(“waring 级别的”) my_log.error(“出错了 级别的”) 五、yagmail发邮件模块 useraccount=&apos;xxxxx@qq.com&apos; password=&apos;xxxx&apos; #邮箱的授权码 mail=yagmail.SMTP(user=useraccount,password=password,host=&apos;smtp.qq.com&apos;,smtp_ssl=True) #smtp_ssl=True,如果是qq邮箱加上这个安全协议的 mail.send(to=[&apos;xxxxx@qq.com&apos;,&apos;xxxxx@qq.com&apos;],cc=&apos;xxxx@qq.com&apos;,subject=&apos;吃了吗？&apos;,contents=&apos;哈哈&apos;,attachments=r&apos;C:\Users\xxx\1.py&apos;) 六、hashlib加密模块 def myMd5(s): s = str(s) m = hashlib.md5(s.encode()) #md5加密必须得传一个bytes类型的，用encode() return m.hexdigest() #获取到加密后的结果]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的模块（一）]]></title>
    <url>%2F2018%2F07%2F03%2FPython%E7%9A%84%E6%A8%A1%E5%9D%97%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、常用模块–OS（提供了非常丰富的方法用来处理文件和目录） import os os.getcwd() #获取当前路径 os.mkdir(‘e:\nhy123’) #创建文件夹 os.makedirs(‘stu\laowang’) #父目录不存在的时候会帮你创建父目录 os.listdir(r’C:\Miniconda3\Scripts’) #获取某个目录下的所有文件 os.rmdir(‘stu’) #删除空文件夹 os.path.join(‘nhy123’,’test0’,’a.txt’) #拼接路径，它会自动识别路径分隔符 os.sep #当前系统的路径分隔符 os.path.dirname(‘e:\nhy123\test0\a.txt’) #获取父目录的路径 os.path.getsize(‘e:\nhy123\test0\a.txt’) #获取文件大小的 os.path.exists(‘code’) #判断文件、文件夹是否存在 os.path.isdir(‘e:\11’) #判断是否是文件夹,如果文件夹不存在的话，会返回False os.path.isfile(r’e:\nhy123\test0\a.txt’) #判断是否是文件，如果文件不存在的话，会返回False os.path.split(r’e:\nhy123\test0\a.txt’) #分割文件名和路径的 二、常用模块-time(日期相关) import time int(time.time()) #获取当前时间戳 time.strftime(‘%Y-%m-%d %H:%M:%S’) #格式化好的时间 time.gmtime() #把时间戳转成时间元组，如果不传时间戳，那么取的是标准时区的时间元组 time.localtime() #把时间戳转成时间元组，如果不传时间戳，那么取的是当前时区的时间 时间戳与格式好的时间互相转换 a、时间戳转格式化好的时间 # 1、首先要把时间戳转成时间元组 # 2、再把时间元组转成格式化好的时间 def timestampToStr(timestamp=None,format=&apos;%Y-%m-%d %H:%M:%S&apos;): if timestamp: time_tuple = time.localtime(timestamp) # 转成时间元组 return time.strftime(format,time_tuple) #把时间元组，转成格式化好的时间 return time.strftime(format) b、格式化好的时间，转时间戳 #1、首先要把格式化好的时间 转成时间元组 #2、再把时间元组转成时间戳 def strToTimestamp(format_time=None,format=&apos;%Y%m%d%H%M%S&apos;): if format_time: time_tuple = time.strptime(format_time, format)#把格式化好的时间，转成时间元组 return int(time.mktime(time_tuple)) return int(time.time())]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的函数（二）]]></title>
    <url>%2F2018%2F07%2F03%2FPython%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、函数相关概念 全局变量：在函数外，上方定义的变量就是全局变量 局部变量：在函数里定义的，出了函数后就不能使用了，如果想在函数里修改全局变量的值，则需要在函数里变量前加关键字global，但是字典跟list这个可变变量，不需要用 global来声明，直接就可以改了。 参数的几个例子： a.可变参数,参数组-元组形式： def send_mail(*args): print(args) send_mail(&apos;1111@qq.com&apos;,&apos;2222@qq.com&apos;,&apos;3333@qq.com&apos;) b.可变参数,参数组-字典形式： def send_mail(**kwargs): print(kwargs) send_mail(k1=&apos;v1&apos;,k2=&apos;v2&apos;) 二、函数的递归 函数自己调用自己，最多循环999次 用递归的话，必须得有一个明确的结束条件 例子： def my2(): num = input(&apos;输入一个数字：&apos;) num = int(num) if num%2 !=0: print(&apos;请输入偶数&apos;) return my2() my2() 三、列表推导式、列表生成式 例子： import random res = [26, 7, 18, 27, 32, 28] for i in range(len(res)): res[i] = str(res[i]).zfill(2) #列表推导式，列表生成式 res1 = [ str(i).zfill(2) for i in res]--等同于上面的for循环 print(res1) res2 = [ i+10 for i in res ] print(res2) hh = [ i for i in range(0,1001,2)] print(hh) 四、内置函数 max(range(1,28)) –最大值，运行结果：27 min(range(28)) –最小值，运行结果：0 sum(range(1,101)) –求和，运行结果：5050 res = sorted([2,3,1,2,3],reverse=True) –排序，加上reverse=True就是降序排列了 res = eval(‘1+1’) –eval,执行python代码，只能执行简单的python代码 f = open(‘code’,encoding=’utf-8’) code = f.read() exec(code) —exec,可执行在文件里的python代码 sql = ‘insert into my_user value ({id},{name},{addr},{sex},{phone}) ‘ sql.format(name=’aaa’,addr=’sdfsfd’,sex=’xxx’,id=11) –format函数是格式化字符串的函数 for index,s in enumerate(stus): print(index,s) –enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中，返回 enumerate(枚举) 对象，如果下标起始位置写为1，就返回的是从序号1开始枚举对象。 for name,se,ag in zip(stus,sex,age):print(name,se,ag) –多个list压缩到一起]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的函数（一）]]></title>
    <url>%2F2018%2F06%2F19%2FPython%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、函数的介绍 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段 如果需要用到函数的处理结果的话，那么就写return，函数里面如果碰到return，函数立即结束 定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。 当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字。 参数 必需参数：def a(b) 调用时必需传入一个参数，a(b) 关键字参数：def s(a,b) 调用时函数调用使用关键字参数来确定传入的参数值，不需要用指定顺序，s(b=1,a=2) 默认参数：def s(a,b=1) 调用函数时，如果没有传递参数，则会使用默认参数值。s(a=1) 不定长参数： 你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数。 def s(a,vartuple) –加了星号 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数 def s(a,vardict) –加了两个星号 的参数会以字典的形式导入 二、函数的使用(例子，校验输入的字符串是否为小数的程序) def check_float(s): s = str(s) if s.count(&apos;.&apos;)==1: s_list = s.split(&apos;.&apos;) left = s_list[0] #小数点左边 right = s_list[1]#小数点右边 if left.isdigit() and right.isdigit(): #这里是判断正小数的 return True if left.startswith(&apos;-&apos;) and left[1:].isdigit() and right.isdigit(): #判断负小数的 return True return False]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的集合]]></title>
    <url>%2F2018%2F06%2F19%2FPython%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[一、集合的介绍 集合天生去重 集合也是无序的 集合的作用主要是关系测试，测试两组数据之前的交集，差集，并集,子集，父集，对称（反向）差集等关系 二、集合的使用方法 a = {6,7,1,2,3,4,5} #创建一个集合 b=set([1,2,3,4,8]) #创建一个集合 a &amp; b #交集，同时存在于a跟b中的，运行结果：{1, 2, 3, 4} a | b # 并集，a与b合并后的结果，运行结果：{1, 2, 3, 4, 5, 6, 7, 8} a -b #差集，a在b中没有的，运行结果：{5, 6, 7} a ^ b # 对称差集，a和b互相没有的，运行结果：{5, 6, 7, 8} a.add(‘x’) #集合中添加一项 a.update([888,999]) #集合中添加多项 a.remove(999) #删除一项，不存在会报错 a.discard(999) #删除一项，不存在不会报错 a.issubset(b) #a是否是b的子集 a.issuperset(b) #a是否是b的父集 三、例子（校验密码是否包含大写字母、小写字母、数字、特殊字符） all_nums = set(string.digits) lower = set(string.ascii_lowercase) upper = set(string.ascii_uppercase) punctuation = set(string.punctuation) for i in range(5): pwd = input(&apos;请输入你的密码：&apos;).strip() pwd = set(pwd) if pwd &amp; all_nums and pwd &amp; lower and pwd &amp; upper and pwd &amp; punctuation: print(&apos;密码合法&apos;) else: print(&apos;密码不合法！&apos;)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的文件读写、Json模块]]></title>
    <url>%2F2018%2F06%2F18%2FPython%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E3%80%81Json%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[一、打开文件的几种模式 使用open()函数打开文件，创建一个file对象，例如：f = open(r’D:\haha.txt’,’a+’,encoding=’utf-8’) 或 with open(r’D:\haha.txt’,’a+’,encoding=’utf-8’) as f –该种写法不用关闭文件，用完自动关闭 文件路径前加’r’是防止字符转义的，如果路径中出现’\t’的话，不加r的话\t就会被转义 ，而加了’r’之后’\t’就能保留原有的样子 几种模式（最常用的是a+）： ‘r’: 默认值，表示从文件读取数据，文件不存在会报错，指针在文件的开头 ‘r+’:打开一个文件用于读写，文件指针将会放在文件的开头。 ‘w’:打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 ‘w+’:打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 ‘a’:打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ‘a+’: 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 二、几个方法 f.seek(0) #将指针的位置移动到开头，例如追加模式下要读取文件 f.read() #读取文件里面所有的内容，字符串 f.readline() #读取一行 f.readlines() #读取文件里的所有内容，返回的是一个list，每一行的内容就作为一个元素在list里面 f.write() #写一个字符串到文件 f.writelines(list) #写一个list，将list里的元素作为一行写入在文件里 f.close() #关闭文件 f.flush() #把缓冲区的数据立即写在磁盘上 f.truncate() #清空文件内容 f.tell() #获取当前文件指针的位置 三、文件修改的高效处理方式 思路： 1、先打开原来的文件，再打开一个空文件 2、循环处理原来文件里面每一行数据，处理完之后，写到新文件里面 3、把原来的文件删除，把新文件的名字改成原来文件的名字 例子： import os with open(&apos;words&apos;,encoding=&apos;utf-8&apos;) as fr, open(&apos;.words&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as fw: for line in fr: line = line.lstrip() #去掉左边的空格 if line:#判断这一行是否有数据 line = line.replace(&apos;你&apos;,&apos;you&apos;)#替换数据 fw.write(line)#写到新文件里面 os.remove(‘words’)#删除原来的文件os.rename(‘.words’,’words’) #把新文件的名字改成原来文件的名字 四、Json模块 import Json json.loads(user_info) #把json串（字符串）转成字典 json.load(f) #这个是直接从文件里拿，不需要再读一次文件了，json帮你读，转成字典了 json.dumps(stu_info) #把字典转成json（字符串） json.dump(stu_info,f,ensure_ascii=False,indent=4) 不需要咱们自己再write了，人家会转成json写入到文件 #ensure_ascii=False 解决了中文写入文件后乱码问题]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的元组、列表截取]]></title>
    <url>%2F2018%2F06%2F17%2FPython%E7%9A%84%E5%85%83%E7%BB%84%E3%80%81%E5%88%97%E8%A1%A8%E6%88%AA%E5%8F%96%2F</url>
    <content type="text"><![CDATA[一、元组介绍 Python的元组与列表类似，不同之处在于元组的元素不能修改。 元组使用小括号，列表使用方括号。例如：tup = (1, 2, 3, 4, 5 ); 元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 元组中只包含一个元素时，需要在元素后面添加逗号。 元组与字符串类似，下标索引从0开始，可以进行截取，组合等。 二、元组的用法 取值（使用下标） tup1[0] tup2[1:5] #顾头不顾尾，取得是下标1到下标4的元素 修改，元组中元素不可修改，但是可以对元组进行连接组合 tup3 = tup1 + tup2; 删除：del tup 将列表转换为元组： tuple(list) 三、切片（列表、字符串、范围取值的一种方法） list[:3] #顾头不顾尾,如果开始的下标不写的话，那么就是从最前面开始 list[-1] #-1代表最后一个元素 list[1:] #如果下标不写的话，代表取到最后 list[:] #开头的下标和结尾的下标都不写的话，代表取整个list list[-6:-10:-1] #第二个冒号后面值代表步长，是隔几个元素取一次，步长是负数的话，从右往左开始取值 list[::-1] #将列表里的元素都取出来了，但是顺序是之前的倒过来，因为步长是负数]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的字典]]></title>
    <url>%2F2018%2F06%2F17%2FPython%E7%9A%84%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[一、字典的介绍 字典是另一种可变容器模型，且可存储任意类型对象。 字典的每个键值 key-value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示： d = {key1 : value1, key2 : value2 } 字典是无序的 字典里的key是唯一的，如果key已有，就覆盖key对应得值，如果key不存在，则插入一条键值对 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组 二、字典的用法 data = { &apos;name&apos;:&apos;张三&apos;, &apos;age&apos;:18, &apos;sex&apos;:&apos;女&apos;} 增加 data[‘email’]=&#39;1000000@qq.com‘ data.setdefault(‘age’,49) #setdefault这种方式，如果key已经存在，不管它，如果key不存在的话，就新增 修改 data[‘sex’]=’男’ 删除 data.pop(‘sex’) #指定的key来删除，key不存在会报错 del data[‘sex’] #指定的key来删除，key不存在会报错 取值 data[‘sex’] data.get(‘sex1’,’haha’) #返回指定键的值，如果值不在字典中返回default值(‘haha’) 其他 data.clear() #清空字典 data.update(data2) #把字典2的键值对加入到字典里 data.items() #以列表返回可遍历的(键, 值) 元组数组 data.keys() #以列表返回一个字典所有的键 data.valus #以列表返回一个字典所有的值 data.popitem() #随机返回并删除字典中的一对键和值 高效循环字典的方式： for k in data: print(k,data.get(k))]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的数据类型、数组、条件判断、循环的基础知识]]></title>
    <url>%2F2018%2F06%2F17%2Fpython%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E3%80%81%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一、数据类型 最常见的数据类型有：整型（int），浮点型（float），字符串（strs）。例如: #整型 a=8 #浮点型 b=8.0 #字符串 c=’hello world’。 数据类型的转换：不同数据类型的变量无法做比较或运算，需要转换后才可，查看变量a的数据类型，使用print(type(a))。例如: #字符串转整型 a=’1’ a =int(a) #整型转字符串 a=1 a=str(a) #整型转浮点型 a=1 a=float(1) 浮点型四舍五入可以用round函数 。 占位符的使用：有时候打印一句话包含了几个变量拼接，中间用加号连接较麻烦，就可以使用占位符。例如：%s 字符串 %d 整数 %f 就是小数 msg = ‘欢迎%s登录，今天是%s’ %(user,today) 二、列表（数组） 数组有一维数组，多维数组，数组的下标从0开始。数组的增删改查，例子： list=[‘a’,’b’,’c’] 增加（在列表的末尾增加一个元素） list.append(‘d’) 运行结果：[‘a’,’b’,’c’,’d’] 增加（在指定位置增加一个元素）list.insert(2,’d’) 运行结果：[‘a’,’b’,’d’,’c’] 删除（删除指定位置的元素） list.pop (2) 或 del list[2] 运行结果：[‘a’,’b’] 删除（删除指定的元素）list.remove(‘a’) 运行结果：[‘b’,’c’] 删除（清空整个list）list.clear() 改 list[0]=’a1’ 运行结果：[‘a’1,’b’,’c’] 查 list[-1] 当下标为-1时就取最后一个元素 list.count(‘a’) 是统计a这个元素在list里出现了几次 其他用法 list.count(‘a’) 是统计a这个元素在list里出现了几次 ， list.index(‘a’)是返回a这个元素第一次出现的下标 ， list.reverse()是反转，数组里的元素反过来排列， list1.extend(list2)是把list2的元素加到list1里面 ， list.sort(reverse=True) 将list里元素降序排列，不带reverse=True就是默认的升序排列 多维数组：my=[[1,2,3,4,5,6],[‘name’,’age’,’sex’,’哈哈’,[‘小明’,’小黑’,’小白’]],890] print(my[1][4][0]) 运行结果：小明 my[1][4].append(‘小紫’) 运行结果：[[1, 2, 3, 4, 5, 6], [‘name’, ‘age’, ‘sex’, ‘哈哈’, [‘小明’, ‘小黑’, ‘小白’, ‘小紫’]], 890] my[1][2]=’性别’ 运行结果：[[1, 2, 3, 4, 5, 6], [‘name’, ‘age’, ‘性别’, ‘哈哈’, [‘小明’, ‘小黑’, ‘小白’]], 890] 三、条件判断 python条件判断基本上就是if-elif-else，例子： if score&gt;=90: print(‘你很优秀’)elif score=80: print(‘良好’)elif score=60: print(‘及格’)else: print(‘不及格’)四、循环 循环就是重复执行循环体里的代码，python里循环有while循环跟for循环。while循环必须有一个计数器。 例子1（while循环）： import random num = random.randint(1,100)#产生一个随机的数字 count = 0 while count&lt;7: guess = input(&apos;请输入你的猜的数字：&apos;) guess = int(guess) if guess&gt;num: print(&apos;大了&apos;) elif guess&lt;num: print(&apos;猜小了&apos;) else: print(&apos;恭喜你猜对了&apos;) break #立即结束整个循环，最下面的else都不会执行 count=count+1 else:#循环正常结束之后，会执行else print(&apos;游戏次数已经用尽，请充值&apos;) 例子2（for循环）： num = 10 for i in range(3): #循环三次 guess = input(&apos;请输入你的猜的数字：&apos;) guess = int(guess) if guess &gt; num: print(&apos;大了&apos;) elif guess &lt; num: print(&apos;猜小了&apos;) else: print(&apos;恭喜你猜对了&apos;) break # 立即结束循环 else: #循环正常结束之后执行的 print(&apos;游戏次数用完了&apos;) 注意循环里break与continue的使用，break是立即结束整个循环，而continue是结束本次循环，进入下一次循环。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的字符串常用方法]]></title>
    <url>%2F2018%2F06%2F17%2FPython%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、字符串常用方法 str.capitalize() #字符串首字母大写 str.center(20,’-‘) #把字符串居中，两边以’-‘填充，长度一共为20 str.index(‘p’) #返回字符’p’在字符中的下标，找不到下标时会报错 str.isalnum() #判断字符串里只能有英文、数字 ，返回布尔值 str.isalpha() #判断是否只为英文的，汉字也可以 str.count(‘a’) #返回’a’字符在字符串中的个数 str.endswith(‘.jpg’) #判断字符串是否以xx结尾 str.startswith(‘138’) #判断字符串是否以xx开头 str.upper() #字母都给变成大写的 str.lower() #字母都给变成小写的 str.find(‘p’) #返回字符’p’在字符中的下标，找不到时就返回-1 str.isdigit() #判断是否为纯数字 str.isspace() #判断是否全都是空格 str.strip() #去掉字符串两边的东西,默认是去掉两边的空格和换行符的 str.lstrip() #只去掉左边的空格跟换行符 str.rstrip() #只去掉右边的空格跟换行符 str.replace(‘a’,’b’) #替换字符串，把前面的a替换成后面的b str.zfill(2) #在前面补0，补到长度为2 str.split(‘,’) #1.以‘,’分割字符串 2.将字符串变成一个list 3.默认是以空格跟换行符分割的 ‘\n’.join(stus) #1.将数组元素以换行符\n来拼接成字符串 2.将list变成字符串 3.以某个字符串连接 str[1] #字符串也可以根据下标来取值 str.format() #字符串的格式化 二、String模块 import String string.ascii_letters #所有的大写+小写字母 string.ascii_lowercase #所有的小写字母 string.ascii_uppercase #所有的大写字母 string.digits #所有的数字 string.punctuation #所有的特殊字符]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓包工具之Charles的基本使用]]></title>
    <url>%2F2018%2F05%2F27%2F%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E4%B9%8BCharles%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、网页抓包 安装好charles工具后打开，点击菜单Proxy下面的Windows Proxy为勾选上，将charles设置为系统代理。如下所示：接下来，在Structure和Sequence两个页签下看到自己电脑通过浏览器发的请求信息啦。Structure是按照 访问的域名分类，而Sequence是按照请求访问的时间排序。如果是https请求，需要安装CA证书文件。 二、手机抓包 首先设置charles，点击菜单栏Proxy，选择Proxy Settings，端口默认是8888，可以不用更改，勾选上Enable transparent HTTP proxying。然后查看自己运行charles电脑的IP地址。接下来再操作手机，前提是电脑与手机在同一个局域网内，点击手机上连接的wifi，点击配置代理，勾选为手动，服务器IP填写为刚刚查看的电脑IP，端口为8888。再点击手机上任何一个软件或浏览器访问，在charles上会弹出一个手机请求连接的提示框，点击允许就可以了，在charles上就可以看到手机上的请求了。 三、过滤 在 Charles 的菜单栏选择 Proxy-&gt;Recording Settings，然后选择 Include 栏，选择Add，然后填入需要监控的协议，主机地址，端口号,这样就达到了过滤的目的。或者在Sequence理的Filter里填写需要过滤到的Host的。 四、模拟弱网络 有时候在测试手机app时需要模拟网速慢的情况，在charles上设置，在Proxy-&gt;Throttle Setting，然后选择Enable Throttling，在Throttle Preset下选择网络类型即可，如下所示：如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。 五、修改网络请求 选中请求后，点击菜单栏的编辑按钮，即可编辑请求，然后再点击Execute就可以重发该请求了。如下所示：六、断点 可以给charles抓到的请求设置断点，来观察或修改发送或者返回的响应信息，要针对某一个请求设置断点，只需要在这个请求网址右击选择Breakpoints，然后点击断点按钮，就可以断点某一个请求了。如下所示：]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>charles</tag>
        <tag>网页抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口测试之Postman、Jmeter的使用（一）]]></title>
    <url>%2F2018%2F05%2F22%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E4%B9%8BPostman%E3%80%81Jmeter%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、接口测试 接口测试就是通过接口文档上的调用地址、请求参数、拼接报文，然后发送请求，检查返回结果。通过接口测试可以早期在功能测试之前发现很多Bug，减少了成本，也可以检查系统的异常处理情况、安全性、稳定性等。 二、Get请求与Post请求的区别 Get使用URL或Cookie传参，而Post将数据放在Body中。（Cookie是维护用户在线状态的，Cookie是存放在用户本地的一个键值对，而session是对应存放在服务器上的一个键值对） Get有长度限制，而Post的数据可以非常大。 一般Get请求用来获取数据，而Post请求用来发送数据。 二、Postman的使用 传参是json类型 点击Body后，选择Raw，最后面默认的text类型换成Json类型 文件上传 点击Body后，key输入框里面的默认的Text换成File类型，然后可选择文件了 三、Jmeter的使用 查看结果树乱码 在jmeter的bin目录下找到jmeter.properties这个文件，添加上sampleresult.default.encoding=utf-8 body data里面有乱码 在jmeter的bin目录下找到jmeter.properties这个文件，添加上jsyntaxtextarea.font.family=Hack Jmeter参数化的几种方式 a.用户定义的变量 b.函数助手（_Random，_time） c.CSV Data Set Config 请求的关联关系处理 a.处理响应为Json类型的，可添加Json的插件，Json Path Extractor 例子： b.正则表达式 操作数据库mysql a.导入jdbc的jar包（测试计划最下面的浏览选择jar包） b.JDBC Connection Configuration配置 ①.添加数据库连接池的名称，后面发sql请求指定连接哪里（Variable Name Bound to Pool） ②.Data Base Url: jdbc:mysql://host:port/dbname?characterEncoding=utf8&amp;allowMultiQueries=true ③.JDBC Driver Class:com.mysql.jdbc.Driver ④.账号、密码]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>接口测试</tag>
        <tag>get请求</tag>
        <tag>post请求</tag>
        <tag>Postman</tag>
        <tag>Jmeter</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
